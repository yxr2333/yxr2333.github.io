{"meta":{"title":"爱学习的小喻同学","subtitle":"","description":"","author":"Xinrui Yu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"启明星工作室秋季结业作品:2048小游戏","slug":"SmallGame","date":"2020-12-11T05:12:50.000Z","updated":"2020-12-11T05:24:08.212Z","comments":true,"path":"2020/12/11/SmallGame/","link":"","permalink":"http://example.com/2020/12/11/SmallGame/","excerpt":"","text":"一、小游戏简介1、起源&emsp;&emsp;2048小游戏最早于2014年3月20日发行。原版的2048最早于GitHub上发行，后被移植到了各个平台。是基于《1024》开发的新型数字游戏 2、玩法&emsp;&emsp;这款游戏的玩法很简单，每次可以选择上下左右滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢，系统也会在空白的地方乱数出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。不断的叠加最终拼凑出2048这个数字就算成功。 二、编程思路 三、各个功能的实现1、图片的制作每个正方形数字图片的大小都为60 * 60像素最后游戏窗体的大小为240 * 300像素、 2、创建2048.h头文件&emsp;&emsp;由于是使用分文件编写的方式(主要是所有函数都写在一个文件里面实在是不方便看)，所以需要创建一个头文件来声明我们需要使用到的库、变量和自定义函数，代码如下： #ifndef SMALLGAME#define SMALLGAME#include &lt;cstdio&gt;#include &lt;conio.h&gt;#include &lt;cstdlib&gt;#include &lt;graphics.h&gt; //用到的第一个非C++自带库---&gt;Easyz的图片库#include &lt;ctime&gt;//由于分文件编写的//所以注意我们定义的变量都要使用extern类型extern IMAGE img[15];//存放的是我们的15张图片extern int map[4][4];//4*4的地图extern int Imagine_number[12];void Loadimage();//加载所有的图片void DrawMap();//根据二维数组中的数据来贴上相应的图片void KeyDown();//模拟按键int RandNum();//在地图中随机产生数据int MoveRight();//向右走int MoveLeft();//向左走int MoveUp();//向上走int MoveDown();//向下走void GAMEOVER();//游戏结束void PLAYERWIN();//游戏获胜int ScanMap2();//扫描判断是否获胜bool ScanMap();//扫描判断是否游戏结束#endif 3、加载图片资源Easyx开发的图片库可以进行图片的操作，在使用图片之前，需要加载要使用的图片，一共需要加载15张图，所以直接编写一个加载图片的函数利用循环加载即可，代码如下： #include &quot;2048.h&quot;#define _CRT_SECURE_NO_WARNINGS //去除内扩增的影响void Loadimage()&#123; //加载所有的图片 for (int i = 0; i &lt; 12; i++) &#123; char FileName[200]=&#123;&#125;; sprintf(FileName,&quot;%d.jpg&quot;,Imagine_number[i]); loadimage(img + i,FileName); &#125; loadimage(img + 12, &quot;111.jpg&quot;); loadimage(img + 13, &quot;12345.jpg&quot;); loadimage(img + 14, &quot;444.jpg&quot;);&#125; 注意：sprintf具有不安全性，如果将一个长度大于原定字符数组大小的字符串存放进字符数组，就会发生越界的现象。可以使用snprintf替换sprintf 4、绘制地图遍历二维数组中的数据，根据二维数组中每个元素的数据来判断应该在某个位置贴上对应的图片，注意需要根据图片的尺寸来计算每个点的x,y坐标。代码如下： #include &quot;2048.h&quot;void DrawMap()&#123;//画地图 setbkcolor(RGB(244,215,215)); //设置窗体背景颜色 cleardevice();//更新一遍窗体 settextcolor(WHITE);//设置文本颜色 settextstyle(30,0,&quot;圆体&quot;);//字体大小 outtextxy(50,10,&quot;2048小游戏&quot;);//文字内容 int x,y,k; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; x=60*j;//列 y=60*i+60;//行 //printf(&quot;%d %d\\n&quot;,x,y); for(k = 0;k &lt; 12;k++)&#123;//遍历12张图片 if(Imagine_number[k] == map[i][j]) //判断应该贴哪一张图片 break;//退出循环 &#125; putimage(x,y,img+k);//在(x,y)的位置贴上第k张图 &#125; &#125;&#125; 5、在二维数组中产生随机数C++中产生随机数需要使用到随机数函数srand();(包含于cstdlib库中)用法：srand((unsigned int)随机数种子(NULL))若随机数种子保持不变，那么所生成的随机数也不会改变（感觉没说清楚，只能自行理解了）。故此我们一般使用电脑的系统时间作为随机数种子，也就是: srand((unsigned int)time(NULL)); 由于这里使用到了系统时间，所以需要包含C++的系统库—-&gt;ctime 在2048小游戏中，每次产生的随机数为2或4。那么如何产生这种随机数？可以这么做👇 temp=(rand()%3) * 2;注意:rand() % n得到的就是[0,n)的数据 &emsp;&emsp;那么不可避免地会生成0这么一个随机数，但我们只需要在生成后判断一次即可，如果是0，那么我们就在其他的区域内继续生成一个随机数。代码如下： #include &quot;2048.h&quot;int RandNum()&#123;//在地图中随机产生数字 srand((unsigned int)time(NULL)); for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; if(map[i][j] == 0)&#123; map[i][j] = (rand()%3)*2; if(map[i][j] == 0) continue; //如果产生的随机数为0 那么就在其他的区域内继续产生随机数 return 0; &#125; &#125; &#125; return 0;&#125; 6、按键操作Ⅰ、数的合并操作&emsp;&emsp;在上下左右的移动过程中，如果移动路径上有可以合并的数，按照规则我们需要进行合并操作； Ⅱ、数的移动&emsp;&emsp;在移动的过程中，如果某个方块在移动路径上没有数字方块，那么我们就需要对该方块进行移动操作； 不同方向上的合并和移动操作的代码是有些许不同的，但是其思想都是一样的下面就以按下右键向右移动为例: #include &quot;2048.h&quot; int MoveRight()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //判断是否可以合并 for(int j = 3;j &gt;= 0;j--)&#123; int k = j - 1;//取当前元素的前一个元素 int NowKey = map[i][j];//取当前的元素 if(NowKey != 0)&#123; // 等于0的时候再去判断是没有意义的 while(k &gt;= 0)&#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; break; //按照规则，每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 3;j&gt;=0;j--)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j - 1; while(k &gt;= 0)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125; &emsp;&emsp;其他三个方向的操作与向右移动类似，不再赘述；此时二维数组中的数据已经发生了更新；（其实如果你不想用图形库的话，可以简单的通过不断的打印二维数组实现类似的效果）更新以后，我们再根据新的数据在对应的位置来贴上对应的图片（可以理解为又覆盖上了一层图片）也就达到了移动的效果。 7、胜局判断 &emsp;&emsp;每次按键+打印地图之后对二维数组进行扫描，一旦发现了2048这个数据，那么直接跳到PLAYERWIN()这个函数。 while (1) &#123; int WINNERCHECK; KeyDown();//按下按键 DrawMap();//打印一遍地图 WINNERCHECK = ScanMap2(); if (WINNERCHECK == 1) &#123; putimage(0, 0, img + 13);//贴上游戏获胜的图片 break; &#125;//游戏获胜&#125; 8、败局判断 &emsp;&emsp;扫描地图，对四个方向尝试移动（只是尝试！没有更新二维数数组中的数据！可以想想该怎么做！），如果有一个方向还可以移动，那么就未达到败局。如果四个方向都已经尝试过且无法移动，那么就已是败局，贴上游戏失败的图片 四、整体代码&emsp;1、头文件 #ifndef SMALLGAME#define SMALLGAME#include &lt;cstdio&gt;#include &lt;conio.h&gt;#include &lt;cstdlib&gt;#include &lt;graphics.h&gt;#include &lt;ctime&gt;extern IMAGE img[15];extern int map[4][4];extern int Imagine_number[12];void Loadimage();//加载所有的图片void DrawMap();//根据二维数组中的数据来贴上相应的图片void KeyDown();//模拟按键int RandNum();//在地图中随机产生数据int MoveRight();//向右走int MoveLeft();//向左走int MoveUp();//向上走int MoveDown();//向下走void GAMEOVER();void PLAYERWIN();int ScanMap1();int ScanMap2();bool ScanMap();#endif &emsp;2、源文件 #include &quot;2048.h&quot;int Imagine_number[12]=&#123;0,2,4,8,16,32,64,128,256,512,1024,2048&#125;;int map[4][4]=&#123;0&#125;;//地图默认全部为0IMAGE img[15];/*****************************************************//*****************************************************///主函数int main()&#123; initgraph(240,300); //创建游戏窗体 Loadimage();//加载图片资源 DrawMap();//打印一遍默认的地图 while(1)&#123; int WINNERCHECK; KeyDown();//按下按键 DrawMap();//打印一遍地图 if (ScanMap() == false) &#123; getchar(); GAMEOVER(); system(&quot;cls&quot;); //putimage(0, 0, img+14); getchar(); break; &#125; WINNERCHECK= ScanMap2(); if (WINNERCHECK== 1) &#123; putimage(0, 0, img + 13); break; &#125;//游戏获胜 &#125; //getchar();//暂停窗体 //closegraph();//关闭窗体 system(&quot;pause&quot;); return 0;&#125;/*****************************************************//*****************************************************///画地图void DrawMap()&#123;//画地图 setbkcolor(RGB(244,215,215)); //设置窗体背景颜色 cleardevice();//更新一遍窗体 settextcolor(WHITE);//设置文本数据 settextstyle(30,0,&quot;楷体&quot;); outtextxy(50,10,&quot;2048小游戏&quot;); int x,y,k; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; x=60*j;//列 y=60*i+60;//行 //printf(&quot;%d %d\\n&quot;,x,y); for(k = 0;k &lt; 12;k++)&#123;//遍历12张图片 if(Imagine_number[k] == map[i][j])//如果图片的标号等于地图中的数据 break;//退出循环 &#125; putimage(x,y,img+k);//在x,y的位置贴上第k章图 &#125; &#125;&#125;/*****************************************************//*****************************************************///游戏结束void GAMEOVER() &#123; closegraph(); initgraph(240, 300); //创建游戏窗体 putimage(0, 0, img + 12); getchar();&#125; /*****************************************************//*****************************************************///模拟按键void KeyDown()&#123; char Key = _getch();//_getch()可以从键盘接受一个字符且不需要按enter键就可以执行 switch(Key) &#123; case &#x27;w&#x27;: case &#x27;W&#x27;: case 72: RandNum();//每次移动都会伴随着移动 MoveUp(); break; case &#x27;s&#x27;: case &#x27;S&#x27;: case 80: RandNum(); MoveDown(); break; case &#x27;a&#x27;: case &#x27;A&#x27;: case 75: RandNum(); MoveLeft(); break; case &#x27;d&#x27;: case &#x27;D&#x27;: case 77: RandNum(); MoveRight(); break; &#125;&#125;/*****************************************************//*****************************************************///加载图片#define _CRT_SECURE_NO_WARNINGS //去掉sprintf内扩增的影响void Loadimage()&#123; //加载所有的图片 loadimage(img + 12, &quot;111.jpg&quot;); loadimage(img + 13, &quot;12345.jpg&quot;); loadimage(img + 14, &quot;444.jpg&quot;); for (int i = 0; i &lt; 12; i++) &#123; char FileName[200]=&#123;&#125;; sprintf(FileName,&quot;%d.jpg&quot;,Imagine_number[i]); loadimage(img + i,FileName); &#125;&#125;/*****************************************************//*****************************************************///移动//不同方向的移动int MoveRight()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //判断是否可以合并 for(int j = 3;j &gt;= 0;j--)&#123; int k = j - 1; int NowKey = map[i][j];//取当前的元素 if(NowKey != 0)&#123; // 等于0的时候再去判断是没有意义的 while(k &gt;= 0)&#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 3;j&gt;=0;j--)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j - 1; while(k &gt;= 0)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125;int MoveLeft()&#123; //向左走 bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(NowKey != 0)&#123; int k = j + 1; while(k &lt; 4)&#123; //不可以越界 int NextKey = map[i][k]; if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j + 1; while(k &lt; 4)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125;int MoveUp()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //i是行 j是列 for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(map[i][j] != 0)&#123; int k = i + 1; while(k &lt; 4)&#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[k][j] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j];//取当前元素 if(map[i][j] == 0)&#123; int k = i+1; while(k &lt; 4)&#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if(map[k][j] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[k][j]=0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if(flag) return 0; else return 4;&#125;int MoveDown()&#123; bool flag = false; for(int i = 3;i &gt;= 0;i--)&#123; //i是行 j是列 for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(NowKey != 0)&#123; int k = i - 1;// while(k &gt;= 0)&#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[k][j] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 3;i&gt;=0;i--)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j];//取当前元素 if(map[i][j] == 0)&#123; int k = i-1; while(k &gt;= 0)&#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if(map[k][j] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[k][j]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if(flag) return 0; else return 4;&#125;/*****************************************************//*****************************************************///生成随机数int RandNum()&#123;//在地图中随机产生数字 srand((unsigned int)time(NULL)); for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; if(map[i][j] == 0)&#123; map[i][j] = (rand()%3)*2; if(map[i][j] == 0) continue; //如果产生的随机数为0 那么就在其他的区域内继续产生随机数 return 0; &#125; &#125; &#125; return 0;&#125;/*****************************************************//*****************************************************///败局判断bool ScanMap() &#123; bool flag = false; /*向右走*/ for (int i = 0; i &lt; 4; i++) &#123; //判断是否可以合并 for (int j = 3; j &gt;= 0; j--) &#123; int k = j - 1; int NowKey = map[i][j];//取当前的元素 if (NowKey != 0) &#123; // 等于0的时候再去判断是没有意义的 while (k &gt;= 0) &#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[i][k] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 3; j &gt;= 0; j--) &#123; int nowkey = map[i][j]; if (map[i][j] == 0) &#123; int k = j - 1; while (k &gt;= 0) &#123; int nowkeynext = map[i][k]; if (map[i][k] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[i][k] = 0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向左走*/ for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (NowKey != 0) &#123; int k = j + 1; while (k &lt; 4) &#123; //不可以越界 int NextKey = map[i][k]; if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; ///map[i][j] *= 2;//那么就进行合并 //map[i][k] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j]; if (map[i][j] == 0) &#123; int k = j + 1; while (k &lt; 4) &#123; int nowkeynext = map[i][k]; if (map[i][k] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[i][k] = 0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向上走*/ for (int i = 0; i &lt; 4; i++) &#123; //i是行 j是列 for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (map[i][j] != 0) &#123; int k = i + 1; while (k &lt; 4) &#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[k][j] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j];//取当前元素 if (map[i][j] == 0) &#123; int k = i + 1; while (k &lt; 4) &#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if (map[k][j] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[k][j] = 0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向下走*/ for (int i = 3; i &gt;= 0; i--) &#123; //i是行 j是列 for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (NowKey != 0) &#123; int k = i - 1;// while (k &gt;= 0) &#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[k][j] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for (int i = 3; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j];//取当前元素 if (map[i][j] == 0) &#123; int k = i - 1; while (k &gt;= 0) &#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if (map[k][j] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[k][j] = 0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag == false) return false; else return true;&#125;/*****************************************************//*****************************************************///胜局判断int ScanMap2() &#123; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (map[i][j] == 2048) return 1; &#125; &#125; return 0;&#125;/*****************************************************/ 五、总结&emsp;&emsp;进工作室以来第一次写小游戏。这一次写小游戏的过程中收获到了不少新东西：&emsp;&emsp;&emsp;&emsp;1、Easyx的图形库的使用&emsp;&emsp;&emsp;&emsp;2、随机数的生成&emsp;&emsp;&emsp;&emsp;3、_getch()和getchar()的区别&emsp;&emsp;&emsp;&emsp;4、sprintf()的用法以及其不安全性&emsp;&emsp;学会了Easyx的图形库以后可以学习做其他的小游戏。然后感觉自己还是有很多不会的东西。图书管理系统写了一小半但是感觉没有API的话写出来也没什么意思，等以后学了Java再继续完成吧。这学期剩下的时间好好复习的同时学习一点Linux服务器的知识，看能不能做出一个属于自己的博客吧！&emsp;&emsp;冲冲冲！","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"这是我的第一篇博客","slug":"my-first-blog","date":"2020-12-10T12:54:02.000Z","updated":"2020-12-11T05:49:02.944Z","comments":true,"path":"2020/12/10/my-first-blog/","link":"","permalink":"http://example.com/2020/12/10/my-first-blog/","excerpt":"","text":"My name is Yu Xinrui This is my first blog on Github OK,Bye bye~","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}