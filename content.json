[{"title":"启明星工作室秋季结业作品:2048小游戏","date":"2020-12-11T05:12:50.000Z","path":"2020/12/11/SmallGame/","text":"一、小游戏简介1、起源&emsp;&emsp;2048小游戏最早于2014年3月20日发行。原版的2048最早于GitHub上发行，后被移植到了各个平台。是基于《1024》开发的新型数字游戏 2、玩法&emsp;&emsp;这款游戏的玩法很简单，每次可以选择上下左右滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢，系统也会在空白的地方乱数出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。不断的叠加最终拼凑出2048这个数字就算成功。 二、编程思路 三、各个功能的实现1、图片的制作每个正方形数字图片的大小都为60 * 60像素最后游戏窗体的大小为240 * 300像素、 2、创建2048.h头文件&emsp;&emsp;由于是使用分文件编写的方式(主要是所有函数都写在一个文件里面实在是不方便看)，所以需要创建一个头文件来声明我们需要使用到的库、变量和自定义函数，代码如下： #ifndef SMALLGAME#define SMALLGAME#include &lt;cstdio&gt;#include &lt;conio.h&gt;#include &lt;cstdlib&gt;#include &lt;graphics.h&gt; //用到的第一个非C++自带库---&gt;Easyz的图片库#include &lt;ctime&gt;//由于分文件编写的//所以注意我们定义的变量都要使用extern类型extern IMAGE img[15];//存放的是我们的15张图片extern int map[4][4];//4*4的地图extern int Imagine_number[12];void Loadimage();//加载所有的图片void DrawMap();//根据二维数组中的数据来贴上相应的图片void KeyDown();//模拟按键int RandNum();//在地图中随机产生数据int MoveRight();//向右走int MoveLeft();//向左走int MoveUp();//向上走int MoveDown();//向下走void GAMEOVER();//游戏结束void PLAYERWIN();//游戏获胜int ScanMap2();//扫描判断是否获胜bool ScanMap();//扫描判断是否游戏结束#endif 3、加载图片资源Easyx开发的图片库可以进行图片的操作，在使用图片之前，需要加载要使用的图片，一共需要加载15张图，所以直接编写一个加载图片的函数利用循环加载即可，代码如下： #include &quot;2048.h&quot;#define _CRT_SECURE_NO_WARNINGS //去除内扩增的影响void Loadimage()&#123; //加载所有的图片 for (int i = 0; i &lt; 12; i++) &#123; char FileName[200]=&#123;&#125;; sprintf(FileName,&quot;%d.jpg&quot;,Imagine_number[i]); loadimage(img + i,FileName); &#125; loadimage(img + 12, &quot;111.jpg&quot;); loadimage(img + 13, &quot;12345.jpg&quot;); loadimage(img + 14, &quot;444.jpg&quot;);&#125; 注意：sprintf具有不安全性，如果将一个长度大于原定字符数组大小的字符串存放进字符数组，就会发生越界的现象。可以使用snprintf替换sprintf 4、绘制地图遍历二维数组中的数据，根据二维数组中每个元素的数据来判断应该在某个位置贴上对应的图片，注意需要根据图片的尺寸来计算每个点的x,y坐标。代码如下： #include &quot;2048.h&quot;void DrawMap()&#123;//画地图 setbkcolor(RGB(244,215,215)); //设置窗体背景颜色 cleardevice();//更新一遍窗体 settextcolor(WHITE);//设置文本颜色 settextstyle(30,0,&quot;圆体&quot;);//字体大小 outtextxy(50,10,&quot;2048小游戏&quot;);//文字内容 int x,y,k; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; x=60*j;//列 y=60*i+60;//行 //printf(&quot;%d %d\\n&quot;,x,y); for(k = 0;k &lt; 12;k++)&#123;//遍历12张图片 if(Imagine_number[k] == map[i][j]) //判断应该贴哪一张图片 break;//退出循环 &#125; putimage(x,y,img+k);//在(x,y)的位置贴上第k张图 &#125; &#125;&#125; 5、在二维数组中产生随机数C++中产生随机数需要使用到随机数函数srand();(包含于cstdlib库中)用法：srand((unsigned int)随机数种子(NULL))若随机数种子保持不变，那么所生成的随机数也不会改变（感觉没说清楚，只能自行理解了）。故此我们一般使用电脑的系统时间作为随机数种子，也就是: srand((unsigned int)time(NULL)); 由于这里使用到了系统时间，所以需要包含C++的系统库—-&gt;ctime 在2048小游戏中，每次产生的随机数为2或4。那么如何产生这种随机数？可以这么做👇 temp=(rand()%3) * 2;注意:rand() % n得到的就是[0,n)的数据 &emsp;&emsp;那么不可避免地会生成0这么一个随机数，但我们只需要在生成后判断一次即可，如果是0，那么我们就在其他的区域内继续生成一个随机数。代码如下： #include &quot;2048.h&quot;int RandNum()&#123;//在地图中随机产生数字 srand((unsigned int)time(NULL)); for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; if(map[i][j] == 0)&#123; map[i][j] = (rand()%3)*2; if(map[i][j] == 0) continue; //如果产生的随机数为0 那么就在其他的区域内继续产生随机数 return 0; &#125; &#125; &#125; return 0;&#125; 6、按键操作Ⅰ、数的合并操作&emsp;&emsp;在上下左右的移动过程中，如果移动路径上有可以合并的数，按照规则我们需要进行合并操作； Ⅱ、数的移动&emsp;&emsp;在移动的过程中，如果某个方块在移动路径上没有数字方块，那么我们就需要对该方块进行移动操作； 不同方向上的合并和移动操作的代码是有些许不同的，但是其思想都是一样的下面就以按下右键向右移动为例: #include &quot;2048.h&quot; int MoveRight()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //判断是否可以合并 for(int j = 3;j &gt;= 0;j--)&#123; int k = j - 1;//取当前元素的前一个元素 int NowKey = map[i][j];//取当前的元素 if(NowKey != 0)&#123; // 等于0的时候再去判断是没有意义的 while(k &gt;= 0)&#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; break; //按照规则，每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 3;j&gt;=0;j--)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j - 1; while(k &gt;= 0)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125; &emsp;&emsp;其他三个方向的操作与向右移动类似，不再赘述；此时二维数组中的数据已经发生了更新；（其实如果你不想用图形库的话，可以简单的通过不断的打印二维数组实现类似的效果）更新以后，我们再根据新的数据在对应的位置来贴上对应的图片（可以理解为又覆盖上了一层图片）也就达到了移动的效果。 7、胜局判断 &emsp;&emsp;每次按键+打印地图之后对二维数组进行扫描，一旦发现了2048这个数据，那么直接跳到PLAYERWIN()这个函数。 while (1) &#123; int WINNERCHECK; KeyDown();//按下按键 DrawMap();//打印一遍地图 WINNERCHECK = ScanMap2(); if (WINNERCHECK == 1) &#123; putimage(0, 0, img + 13);//贴上游戏获胜的图片 break; &#125;//游戏获胜&#125; 8、败局判断 &emsp;&emsp;扫描地图，对四个方向尝试移动（只是尝试！没有更新二维数数组中的数据！可以想想该怎么做！），如果有一个方向还可以移动，那么就未达到败局。如果四个方向都已经尝试过且无法移动，那么就已是败局，贴上游戏失败的图片 四、整体代码&emsp;1、头文件 #ifndef SMALLGAME#define SMALLGAME#include &lt;cstdio&gt;#include &lt;conio.h&gt;#include &lt;cstdlib&gt;#include &lt;graphics.h&gt;#include &lt;ctime&gt;extern IMAGE img[15];extern int map[4][4];extern int Imagine_number[12];void Loadimage();//加载所有的图片void DrawMap();//根据二维数组中的数据来贴上相应的图片void KeyDown();//模拟按键int RandNum();//在地图中随机产生数据int MoveRight();//向右走int MoveLeft();//向左走int MoveUp();//向上走int MoveDown();//向下走void GAMEOVER();void PLAYERWIN();int ScanMap1();int ScanMap2();bool ScanMap();#endif &emsp;2、源文件 #include &quot;2048.h&quot;int Imagine_number[12]=&#123;0,2,4,8,16,32,64,128,256,512,1024,2048&#125;;int map[4][4]=&#123;0&#125;;//地图默认全部为0IMAGE img[15];/*****************************************************//*****************************************************///主函数int main()&#123; initgraph(240,300); //创建游戏窗体 Loadimage();//加载图片资源 DrawMap();//打印一遍默认的地图 while(1)&#123; int WINNERCHECK; KeyDown();//按下按键 DrawMap();//打印一遍地图 if (ScanMap() == false) &#123; getchar(); GAMEOVER(); system(&quot;cls&quot;); //putimage(0, 0, img+14); getchar(); break; &#125; WINNERCHECK= ScanMap2(); if (WINNERCHECK== 1) &#123; putimage(0, 0, img + 13); break; &#125;//游戏获胜 &#125; //getchar();//暂停窗体 //closegraph();//关闭窗体 system(&quot;pause&quot;); return 0;&#125;/*****************************************************//*****************************************************///画地图void DrawMap()&#123;//画地图 setbkcolor(RGB(244,215,215)); //设置窗体背景颜色 cleardevice();//更新一遍窗体 settextcolor(WHITE);//设置文本数据 settextstyle(30,0,&quot;楷体&quot;); outtextxy(50,10,&quot;2048小游戏&quot;); int x,y,k; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; x=60*j;//列 y=60*i+60;//行 //printf(&quot;%d %d\\n&quot;,x,y); for(k = 0;k &lt; 12;k++)&#123;//遍历12张图片 if(Imagine_number[k] == map[i][j])//如果图片的标号等于地图中的数据 break;//退出循环 &#125; putimage(x,y,img+k);//在x,y的位置贴上第k章图 &#125; &#125;&#125;/*****************************************************//*****************************************************///游戏结束void GAMEOVER() &#123; closegraph(); initgraph(240, 300); //创建游戏窗体 putimage(0, 0, img + 12); getchar();&#125; /*****************************************************//*****************************************************///模拟按键void KeyDown()&#123; char Key = _getch();//_getch()可以从键盘接受一个字符且不需要按enter键就可以执行 switch(Key) &#123; case &#x27;w&#x27;: case &#x27;W&#x27;: case 72: RandNum();//每次移动都会伴随着移动 MoveUp(); break; case &#x27;s&#x27;: case &#x27;S&#x27;: case 80: RandNum(); MoveDown(); break; case &#x27;a&#x27;: case &#x27;A&#x27;: case 75: RandNum(); MoveLeft(); break; case &#x27;d&#x27;: case &#x27;D&#x27;: case 77: RandNum(); MoveRight(); break; &#125;&#125;/*****************************************************//*****************************************************///加载图片#define _CRT_SECURE_NO_WARNINGS //去掉sprintf内扩增的影响void Loadimage()&#123; //加载所有的图片 loadimage(img + 12, &quot;111.jpg&quot;); loadimage(img + 13, &quot;12345.jpg&quot;); loadimage(img + 14, &quot;444.jpg&quot;); for (int i = 0; i &lt; 12; i++) &#123; char FileName[200]=&#123;&#125;; sprintf(FileName,&quot;%d.jpg&quot;,Imagine_number[i]); loadimage(img + i,FileName); &#125;&#125;/*****************************************************//*****************************************************///移动//不同方向的移动int MoveRight()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //判断是否可以合并 for(int j = 3;j &gt;= 0;j--)&#123; int k = j - 1; int NowKey = map[i][j];//取当前的元素 if(NowKey != 0)&#123; // 等于0的时候再去判断是没有意义的 while(k &gt;= 0)&#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 3;j&gt;=0;j--)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j - 1; while(k &gt;= 0)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125;int MoveLeft()&#123; //向左走 bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(NowKey != 0)&#123; int k = j + 1; while(k &lt; 4)&#123; //不可以越界 int NextKey = map[i][k]; if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j + 1; while(k &lt; 4)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125;int MoveUp()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //i是行 j是列 for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(map[i][j] != 0)&#123; int k = i + 1; while(k &lt; 4)&#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[k][j] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j];//取当前元素 if(map[i][j] == 0)&#123; int k = i+1; while(k &lt; 4)&#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if(map[k][j] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[k][j]=0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if(flag) return 0; else return 4;&#125;int MoveDown()&#123; bool flag = false; for(int i = 3;i &gt;= 0;i--)&#123; //i是行 j是列 for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(NowKey != 0)&#123; int k = i - 1;// while(k &gt;= 0)&#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[k][j] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 3;i&gt;=0;i--)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j];//取当前元素 if(map[i][j] == 0)&#123; int k = i-1; while(k &gt;= 0)&#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if(map[k][j] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[k][j]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if(flag) return 0; else return 4;&#125;/*****************************************************//*****************************************************///生成随机数int RandNum()&#123;//在地图中随机产生数字 srand((unsigned int)time(NULL)); for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; if(map[i][j] == 0)&#123; map[i][j] = (rand()%3)*2; if(map[i][j] == 0) continue; //如果产生的随机数为0 那么就在其他的区域内继续产生随机数 return 0; &#125; &#125; &#125; return 0;&#125;/*****************************************************//*****************************************************///败局判断bool ScanMap() &#123; bool flag = false; /*向右走*/ for (int i = 0; i &lt; 4; i++) &#123; //判断是否可以合并 for (int j = 3; j &gt;= 0; j--) &#123; int k = j - 1; int NowKey = map[i][j];//取当前的元素 if (NowKey != 0) &#123; // 等于0的时候再去判断是没有意义的 while (k &gt;= 0) &#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[i][k] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 3; j &gt;= 0; j--) &#123; int nowkey = map[i][j]; if (map[i][j] == 0) &#123; int k = j - 1; while (k &gt;= 0) &#123; int nowkeynext = map[i][k]; if (map[i][k] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[i][k] = 0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向左走*/ for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (NowKey != 0) &#123; int k = j + 1; while (k &lt; 4) &#123; //不可以越界 int NextKey = map[i][k]; if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; ///map[i][j] *= 2;//那么就进行合并 //map[i][k] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j]; if (map[i][j] == 0) &#123; int k = j + 1; while (k &lt; 4) &#123; int nowkeynext = map[i][k]; if (map[i][k] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[i][k] = 0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向上走*/ for (int i = 0; i &lt; 4; i++) &#123; //i是行 j是列 for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (map[i][j] != 0) &#123; int k = i + 1; while (k &lt; 4) &#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[k][j] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j];//取当前元素 if (map[i][j] == 0) &#123; int k = i + 1; while (k &lt; 4) &#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if (map[k][j] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[k][j] = 0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向下走*/ for (int i = 3; i &gt;= 0; i--) &#123; //i是行 j是列 for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (NowKey != 0) &#123; int k = i - 1;// while (k &gt;= 0) &#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[k][j] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for (int i = 3; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j];//取当前元素 if (map[i][j] == 0) &#123; int k = i - 1; while (k &gt;= 0) &#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if (map[k][j] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[k][j] = 0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag == false) return false; else return true;&#125;/*****************************************************//*****************************************************///胜局判断int ScanMap2() &#123; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (map[i][j] == 2048) return 1; &#125; &#125; return 0;&#125;/*****************************************************/ 五、总结&emsp;&emsp;进工作室以来第一次写小游戏。这一次写小游戏的过程中收获到了不少新东西：&emsp;&emsp;&emsp;&emsp;1、Easyx的图形库的使用&emsp;&emsp;&emsp;&emsp;2、随机数的生成&emsp;&emsp;&emsp;&emsp;3、_getch()和getchar()的区别&emsp;&emsp;&emsp;&emsp;4、sprintf()的用法以及其不安全性&emsp;&emsp;学会了Easyx的图形库以后可以学习做其他的小游戏。然后感觉自己还是有很多不会的东西。图书管理系统写了一小半但是感觉没有API的话写出来也没什么意思，等以后学了Java再继续完成吧。这学期剩下的时间好好复习的同时学习一点Linux服务器的知识，看能不能做出一个属于自己的博客吧！&emsp;&emsp;冲冲冲！","raw":"---\ntitle: 启明星工作室秋季结业作品:2048小游戏\ndate: 2020-12-11 13:12:50\ntags: \n\t- C\n---\n\n# 一、小游戏简介\n## 1、起源\n&emsp;&emsp;2048小游戏最早于2014年3月20日发行。原版的2048最早于GitHub上发行，后被移植到了各个平台。是基于《1024》开发的新型数字游戏\n## 2、玩法\n&emsp;&emsp;这款游戏的玩法很简单，每次可以选择上下左右滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢，系统也会在空白的地方乱数出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。不断的叠加最终拼凑出2048这个数字就算成功。\n# 二、编程思路\n![未命名文件.jpg](https://img-blog.csdnimg.cn/img_convert/92d01392c0024d581a243e9b5145b2f4.png)\n# 三、各个功能的实现\n## 1、图片的制作\n每个正方形数字图片的大小都为60 * 60像素\n最后游戏窗体的大小为240 * 300像素、\n## 2、创建2048.h头文件\n&emsp;&emsp;由于是使用分文件编写的方式(主要是所有函数都写在一个文件里面实在是不方便看)，所以需要创建一个头文件来声明我们需要使用到的库、变量和自定义函数，代码如下：\n\n```cpp\n#ifndef SMALLGAME\n#define SMALLGAME\n#include <cstdio>\n#include <conio.h>\n#include <cstdlib>\n#include <graphics.h> //用到的第一个非C++自带库--->Easyz的图片库\n#include <ctime>\n//由于分文件编写的\n//所以注意我们定义的变量都要使用extern类型\nextern IMAGE img[15];//存放的是我们的15张图片\nextern int map[4][4];//4*4的地图\nextern int Imagine_number[12];\nvoid Loadimage();//加载所有的图片\nvoid DrawMap();//根据二维数组中的数据来贴上相应的图片\nvoid KeyDown();//模拟按键\nint RandNum();//在地图中随机产生数据\nint MoveRight();//向右走\nint MoveLeft();//向左走\nint MoveUp();//向上走\nint MoveDown();//向下走\nvoid GAMEOVER();//游戏结束\nvoid PLAYERWIN();//游戏获胜\nint ScanMap2();//扫描判断是否获胜\nbool ScanMap();//扫描判断是否游戏结束\n#endif\n```\n## 3、加载图片资源\nEasyx开发的图片库可以进行图片的操作，在使用图片之前，需要加载要使用的图片，一共需要加载15张图，所以直接编写一个加载图片的函数利用循环加载即可，代码如下：\n\n```cpp\n#include \"2048.h\"\n#define _CRT_SECURE_NO_WARNINGS //去除内扩增的影响\nvoid Loadimage(){  //加载所有的图片\n\tfor (int i = 0; i < 12; i++) {\n\t\tchar FileName[200]={};\n\t\tsprintf(FileName,\"%d.jpg\",Imagine_number[i]);\n\t\tloadimage(img + i,FileName);\n\t}\n\tloadimage(img + 12, \"111.jpg\");\n\tloadimage(img + 13, \"12345.jpg\");\n\tloadimage(img + 14, \"444.jpg\");\n}\n```\n注意：sprintf具有不安全性，如果将一个长度大于原定字符数组大小的字符串存放进字符数组，就会发生越界的现象。可以使用snprintf替换sprintf\n## 4、绘制地图\n遍历二维数组中的数据，根据二维数组中每个元素的数据来判断应该在某个位置贴上对应的图片，注意需要根据图片的尺寸来计算每个点的x,y坐标。\n代码如下：\n\n```cpp\n#include \"2048.h\"\nvoid DrawMap(){//画地图\n\tsetbkcolor(RGB(244,215,215));  //设置窗体背景颜色\n\tcleardevice();//更新一遍窗体\n\tsettextcolor(WHITE);//设置文本颜色\n\tsettextstyle(30,0,\"圆体\");//字体大小\n\touttextxy(50,10,\"2048小游戏\");//文字内容\n\tint x,y,k;\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tx=60*j;//列\n\t\t\ty=60*i+60;//行\n\t\t\t//printf(\"%d %d\\n\",x,y);\n\t\t\tfor(k = 0;k < 12;k++){//遍历12张图片\n\t\t\t\tif(Imagine_number[k] == map[i][j])\n\t\t\t\t//判断应该贴哪一张图片\n\t\t\t\t\tbreak;//退出循环\n\t\t\t}\n\t\t\tputimage(x,y,img+k);//在(x,y)的位置贴上第k张图\n\t\t}\n\t}\n}\n```\n\n## 5、在二维数组中产生随机数\nC++中产生随机数需要使用到随机数函数srand();(包含于cstdlib库中)\n用法：srand((unsigned int)随机数种子(NULL))\n若随机数种子保持不变，那么所生成的随机数也不会改变（感觉没说清楚，只能自行理解了）。故此我们一般使用电脑的系统时间作为随机数种子，也就是:\n```\nsrand((unsigned int)time(NULL));\n```\n由于这里使用到了系统时间，所以需要包含C++的系统库---->**ctime**\n\n在2048小游戏中，每次产生的随机数为2或4。\n那么如何产生这种随机数？可以这么做👇\n```\ntemp=(rand()%3) * 2;\n注意:rand() % n得到的就是[0,n)的数据\n```\n&emsp;&emsp;那么不可避免地会生成0这么一个随机数，但我们只需要在生成后判断一次即可，如果是0，那么我们就在其他的区域内继续生成一个随机数。\n代码如下：\n```cpp\n#include \"2048.h\"\nint RandNum(){//在地图中随机产生数字\n\tsrand((unsigned int)time(NULL));\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tmap[i][j] = (rand()%3)*2;\n\t\t\t\tif(map[i][j] == 0) continue;  //如果产生的随机数为0  那么就在其他的区域内继续产生随机数\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## 6、按键操作\n### Ⅰ、数的合并操作\n&emsp;&emsp;在上下左右的移动过程中，如果移动路径上有可以合并的数，按照规则我们需要进行合并操作；\n\n### Ⅱ、数的移动\n&emsp;&emsp;在移动的过程中，如果某个方块在移动路径上没有数字方块，那么我们就需要对该方块进行移动操作；\n ```\n 不同方向上的合并和移动操作的代码是有些许不同的，但是其思想都是一样的\n 下面就以按下右键向右移动为例:\n ```\n ```cpp\n #include \"2048.h\"\n int MoveRight(){\n\tbool flag = false;\n\tfor(int i = 0;i < 4;i++){  //判断是否可以合并\n\t\tfor(int j = 3;j >= 0;j--){  \n\t\t\tint k = j - 1;//取当前元素的前一个元素\n\t\t\tint NowKey = map[i][j];//取当前的元素\n\t\t\tif(NowKey != 0){ // 等于0的时候再去判断是没有意义的\n\t\t\t\twhile(k >= 0){  //列指针移动\n\t\t\t\t\tint NextKey = map[i][k];//取当前元素的下一个元素\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;  //按照规则，每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i<4;i++){\n\t\tfor(int j = 3;j>=0;j--){\n\t\t\tint nowkey = map[i][j];\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = j - 1;\n\t\t\t\twhile(k >= 0){\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif(map[i][k] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[i][k]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tif (flag) return 0;\n\telse return 4;\n}\n ```\n &emsp;&emsp;其他三个方向的操作与向右移动类似，不再赘述；此时二维数组中的数据已经发生了更新；（其实如果你不想用图形库的话，可以简单的通过不断的打印二维数组实现类似的效果）更新以后，我们再根据新的数据在对应的位置来贴上对应的图片（可以理解为又覆盖上了一层图片）也就达到了移动的效果。\n ## 7、胜局判断\n &emsp;&emsp;每次按键+打印地图之后对二维数组进行扫描，一旦发现了2048这个数据，那么直接跳到PLAYERWIN()这个函数。\n ```cpp\n \twhile (1) \n \t{\n\t\t\tint WINNERCHECK;\n\t\t\tKeyDown();//按下按键\n\t\t\tDrawMap();//打印一遍地图\n\t\t\tWINNERCHECK = ScanMap2();\n\t\t\tif (WINNERCHECK == 1) \n\t\t\t{\n\t\t\t\tputimage(0, 0, img + 13);//贴上游戏获胜的图片\n\t\t\t\tbreak; \n\t\t\t}//游戏获胜\n\t}\n ```\n ## 8、败局判断\n &emsp;&emsp;扫描地图，对四个方向尝试移动（只是尝试！没有更新二维数数组中的数据！可以想想该怎么做！），如果有一个方向还可以移动，那么就未达到败局。如果四个方向都已经尝试过且无法移动，那么就已是败局，贴上游戏失败的图片\n\n # 四、整体代码\n&emsp;1、头文件\n```cpp\n#ifndef SMALLGAME\n#define SMALLGAME\n#include <cstdio>\n#include <conio.h>\n#include <cstdlib>\n#include <graphics.h>\n#include <ctime>\nextern IMAGE img[15];\nextern int map[4][4];\nextern int Imagine_number[12];\nvoid Loadimage();//加载所有的图片\nvoid DrawMap();//根据二维数组中的数据来贴上相应的图片\nvoid KeyDown();//模拟按键\nint RandNum();//在地图中随机产生数据\nint MoveRight();//向右走\nint MoveLeft();//向左走\nint MoveUp();//向上走\nint MoveDown();//向下走\nvoid GAMEOVER();\nvoid PLAYERWIN();\nint ScanMap1();\nint ScanMap2();\nbool ScanMap();\n#endif\n```\n&emsp;2、源文件\n```cpp\n#include \"2048.h\"\nint Imagine_number[12]={0,2,4,8,16,32,64,128,256,512,1024,2048};\nint map[4][4]={0};//地图默认全部为0\nIMAGE img[15];\n/*****************************************************/\n\n/*****************************************************/\n//主函数\nint main(){\n\tinitgraph(240,300);  //创建游戏窗体\n\tLoadimage();//加载图片资源\n\tDrawMap();//打印一遍默认的地图\n\twhile(1){\n\t\tint WINNERCHECK;\n\t\tKeyDown();//按下按键\n\t\tDrawMap();//打印一遍地图\n\t\tif (ScanMap() == false) {\n\t\t\tgetchar();\n\t\t\tGAMEOVER();\n\t\t\tsystem(\"cls\");\n\t\t\t//putimage(0, 0, img+14);\n\t\t\tgetchar();\n\t\t\tbreak;\n\t\t}\n\t\tWINNERCHECK= ScanMap2();\n\t\tif (WINNERCHECK== 1) { putimage(0, 0, img + 13); break; }//游戏获胜\n\t}\n\t//getchar();//暂停窗体\n\t//closegraph();//关闭窗体\n\tsystem(\"pause\");\n\treturn 0;\n}\n/*****************************************************/\n\n/*****************************************************/\n//画地图\nvoid DrawMap(){//画地图\n\tsetbkcolor(RGB(244,215,215));  //设置窗体背景颜色\n\tcleardevice();//更新一遍窗体\n\tsettextcolor(WHITE);//设置文本数据\n\tsettextstyle(30,0,\"楷体\");\n\touttextxy(50,10,\"2048小游戏\");\n\tint x,y,k;\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tx=60*j;//列\n\t\t\ty=60*i+60;//行\n\t\t\t//printf(\"%d %d\\n\",x,y);\n\t\t\tfor(k = 0;k < 12;k++){//遍历12张图片\n\t\t\t\tif(Imagine_number[k] == map[i][j])//如果图片的标号等于地图中的数据\n\t\t\t\t\tbreak;//退出循环\n\t\t\t}\n\t\t\tputimage(x,y,img+k);//在x,y的位置贴上第k章图\n\t\t}\n\t}\n}\n/*****************************************************/\n\n/*****************************************************/\n//游戏结束\nvoid GAMEOVER() {\n\tclosegraph();\n\tinitgraph(240, 300);  //创建游戏窗体\n\tputimage(0, 0, img + 12);\n\tgetchar();\n} \n/*****************************************************/\n\n/*****************************************************/\n//模拟按键\nvoid KeyDown(){\n\tchar Key = _getch();//_getch()可以从键盘接受一个字符且不需要按enter键就可以执行\n\tswitch(Key)\n\t{\n\t\tcase 'w':\n\t\tcase 'W':\n\t\tcase  72:\n\t\t\tRandNum();//每次移动都会伴随着移动\n\t\t\tMoveUp();\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\tcase  80:\n\t\t\tRandNum();\n\t\t\tMoveDown();\t\t\t\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'A': \n\t\tcase 75:\n\t\t\tRandNum();\n\t\t\tMoveLeft();\t\t\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\tcase 77:\n\t\t\tRandNum();\n\t\t\tMoveRight();\t\t\n\t\t\tbreak;\n\t}\n}\n/*****************************************************/\n\n/*****************************************************/\n//加载图片\n#define _CRT_SECURE_NO_WARNINGS //去掉sprintf内扩增的影响\nvoid Loadimage(){  //加载所有的图片\n\tloadimage(img + 12, \"111.jpg\");\n\tloadimage(img + 13, \"12345.jpg\");\n\tloadimage(img + 14, \"444.jpg\");\n\tfor (int i = 0; i < 12; i++) {\n\t\tchar FileName[200]={};\n\t\tsprintf(FileName,\"%d.jpg\",Imagine_number[i]);\n\t\tloadimage(img + i,FileName);\n\t}\n}\n/*****************************************************/\n\n/*****************************************************/\n//移动\n//不同方向的移动\nint MoveRight(){\n\tbool flag = false;\n\tfor(int i = 0;i < 4;i++){  //判断是否可以合并\n\t\tfor(int j = 3;j >= 0;j--){  \n\t\t\tint k = j - 1;\n\t\t\tint NowKey = map[i][j];//取当前的元素\n\t\t\tif(NowKey != 0){ // 等于0的时候再去判断是没有意义的\n\t\t\t\twhile(k >= 0){  //列指针移动\n\t\t\t\t\tint NextKey = map[i][k];//取当前元素的下一个元素\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=-1;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i<4;i++){\n\t\tfor(int j = 3;j>=0;j--){\n\t\t\tint nowkey = map[i][j];\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = j - 1;\n\t\t\t\twhile(k >= 0){\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif(map[i][k] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[i][k]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tif (flag) return 0;\n\telse return 4;\n}\nint MoveLeft(){  //向左走\n\tbool flag = false;\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif(NowKey != 0){\n\t\t\t\tint k = j + 1;\n\t\t\t\twhile(k < 4){  //不可以越界\n\t\t\t\t\tint NextKey = map[i][k];\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=4;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i<4;i++){\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tint nowkey = map[i][j];\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = j + 1;\n\t\t\t\twhile(k < 4){\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif(map[i][k] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[i][k]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk++;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag) return 0;\n\telse return 4;\n}\nint MoveUp(){\n\tbool flag = false;\n\tfor(int i = 0;i < 4;i++){ //i是行 j是列\n\t\tfor(int j = 0;j < 4;j++){  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif(map[i][j] != 0){\n\t\t\t\tint k = i + 1;\n\t\t\t\twhile(k < 4){  //不可以越界\n\t\t\t\t\tint NextKey = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[k][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=4;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i<4;i++){\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tint nowkey = map[i][j];//取当前元素\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = i+1;\n\t\t\t\twhile(k < 4){\n\t\t\t\t\tint nowkeynext = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif(map[k][j] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[k][j]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk++;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag) return 0;\n\telse return 4;\n}\nint MoveDown(){\n\tbool flag = false;\n\tfor(int i = 3;i >= 0;i--){ //i是行 j是列\n\t\tfor(int j = 0;j < 4;j++){  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif(NowKey != 0){\n\t\t\t\tint k = i - 1;//\n\t\t\t\twhile(k >= 0){  //不可以越界\n\t\t\t\t\tint NextKey = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[k][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=-1;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 3;i>=0;i--){\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tint nowkey = map[i][j];//取当前元素\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = i-1;\n\t\t\t\twhile(k >= 0){\n\t\t\t\t\tint nowkeynext = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif(map[k][j] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[k][j]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag) return 0;\n\telse return 4;\n}\n/*****************************************************/\n\n/*****************************************************/\n//生成随机数\nint RandNum(){//在地图中随机产生数字\n\tsrand((unsigned int)time(NULL));\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tmap[i][j] = (rand()%3)*2;\n\t\t\t\tif(map[i][j] == 0) continue;  //如果产生的随机数为0  那么就在其他的区域内继续产生随机数\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*****************************************************/\n\n/*****************************************************/\n//败局判断\nbool ScanMap() {\n\tbool flag = false;\n\t/*向右走*/\n\tfor (int i = 0; i < 4; i++) {  //判断是否可以合并\n\t\tfor (int j = 3; j >= 0; j--) {\n\t\t\tint k = j - 1;\n\t\t\tint NowKey = map[i][j];//取当前的元素\n\t\t\tif (NowKey != 0) { // 等于0的时候再去判断是没有意义的\n\t\t\t\twhile (k >= 0) {  //列指针移动\n\t\t\t\t\tint NextKey = map[i][k];//取当前元素的下一个元素\n\t\t\t\t\tif (NextKey != 0) { //如果下一个块已经有数据\n\t\t\t\t\t\tif (NextKey == NowKey) {  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t//map[i][j] *= 2;//那么就进行合并\n\t\t\t\t\t\t\t//map[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=-1;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 3; j >= 0; j--) {\n\t\t\tint nowkey = map[i][j];\n\t\t\tif (map[i][j] == 0) {\n\t\t\t\tint k = j - 1;\n\t\t\t\twhile (k >= 0) {\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif (map[i][k] != 0) {  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t//map[i][j] = nowkeynext;\n\t\t\t\t\t\t//map[i][k] = 0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t/*向左走*/\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 4; j++) {  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif (NowKey != 0) {\n\t\t\t\tint k = j + 1;\n\t\t\t\twhile (k < 4) {  //不可以越界\n\t\t\t\t\tint NextKey = map[i][k];\n\t\t\t\t\tif (NextKey != 0) { //如果下一个块已经有数据\n\t\t\t\t\t\tif (NextKey == NowKey) {  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t///map[i][j] *= 2;//那么就进行合并\n\t\t\t\t\t\t\t//map[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=4;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint nowkey = map[i][j];\n\t\t\tif (map[i][j] == 0) {\n\t\t\t\tint k = j + 1;\n\t\t\t\twhile (k < 4) {\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif (map[i][k] != 0) {  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t//map[i][j] = nowkeynext;\n\t\t\t\t\t\t//map[i][k] = 0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk++;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*向上走*/\n\tfor (int i = 0; i < 4; i++) { //i是行 j是列\n\t\tfor (int j = 0; j < 4; j++) {  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif (map[i][j] != 0) {\n\t\t\t\tint k = i + 1;\n\t\t\t\twhile (k < 4) {  //不可以越界\n\t\t\t\t\tint NextKey = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif (NextKey != 0) { //如果下一个块已经有数据\n\t\t\t\t\t\tif (NextKey == NowKey) {  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t//map[i][j] *= 2;//那么就进行合并\n\t\t\t\t\t\t\t//map[k][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=4;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint nowkey = map[i][j];//取当前元素\n\t\t\tif (map[i][j] == 0) {\n\t\t\t\tint k = i + 1;\n\t\t\t\twhile (k < 4) {\n\t\t\t\t\tint nowkeynext = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif (map[k][j] != 0) {  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t//map[i][j] = nowkeynext;\n\t\t\t\t\t\t//map[k][j] = 0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk++;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*向下走*/\n\tfor (int i = 3; i >= 0; i--) { //i是行 j是列\n\t\tfor (int j = 0; j < 4; j++) {  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif (NowKey != 0) {\n\t\t\t\tint k = i - 1;//\n\t\t\t\twhile (k >= 0) {  //不可以越界\n\t\t\t\t\tint NextKey = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif (NextKey != 0) { //如果下一个块已经有数据\n\t\t\t\t\t\tif (NextKey == NowKey) {  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t//map[i][j] *= 2;//那么就进行合并\n\t\t\t\t\t\t\t//map[k][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=-1;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 3; i >= 0; i--) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint nowkey = map[i][j];//取当前元素\n\t\t\tif (map[i][j] == 0) {\n\t\t\t\tint k = i - 1;\n\t\t\t\twhile (k >= 0) {\n\t\t\t\t\tint nowkeynext = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif (map[k][j] != 0) {  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t//map[i][j] = nowkeynext;\n\t\t\t\t\t\t//map[k][j] = 0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == false) return false;\n\telse return true;\n}\n/*****************************************************/\n\n/*****************************************************/\n//胜局判断\nint ScanMap2() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (map[i][j] == 2048) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n/*****************************************************/\n```\n\n# 五、总结\n&emsp;&emsp;进工作室以来第一次写小游戏。这一次写小游戏的过程中收获到了不少新东西：\n&emsp;&emsp;&emsp;&emsp;1、**Easyx的图形库的使用**\n&emsp;&emsp;&emsp;&emsp;2、随机数的生成\n&emsp;&emsp;&emsp;&emsp;3、_getch()和getchar()的区别\n&emsp;&emsp;&emsp;&emsp;4、sprintf()的用法以及其不安全性\n&emsp;&emsp;学会了Easyx的图形库以后可以学习做其他的小游戏。然后感觉自己还是有很多不会的东西。图书管理系统写了一小半但是感觉没有API的话写出来也没什么意思，等以后学了Java再继续完成吧。这学期剩下的时间好好复习的同时学习一点Linux服务器的知识，看能不能做出一个属于自己的博客吧！\n&emsp;&emsp;冲冲冲！","content":"<h1 id=\"一、小游戏简介\"><a href=\"#一、小游戏简介\" class=\"headerlink\" title=\"一、小游戏简介\"></a>一、小游戏简介</h1><h2 id=\"1、起源\"><a href=\"#1、起源\" class=\"headerlink\" title=\"1、起源\"></a>1、起源</h2><p>&emsp;&emsp;2048小游戏最早于2014年3月20日发行。原版的2048最早于GitHub上发行，后被移植到了各个平台。是基于《1024》开发的新型数字游戏</p>\n<h2 id=\"2、玩法\"><a href=\"#2、玩法\" class=\"headerlink\" title=\"2、玩法\"></a>2、玩法</h2><p>&emsp;&emsp;这款游戏的玩法很简单，每次可以选择上下左右滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢，系统也会在空白的地方乱数出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。不断的叠加最终拼凑出2048这个数字就算成功。</p>\n<h1 id=\"二、编程思路\"><a href=\"#二、编程思路\" class=\"headerlink\" title=\"二、编程思路\"></a>二、编程思路</h1><p><img src=\"https://img-blog.csdnimg.cn/img_convert/92d01392c0024d581a243e9b5145b2f4.png\" alt=\"未命名文件.jpg\"></p>\n<h1 id=\"三、各个功能的实现\"><a href=\"#三、各个功能的实现\" class=\"headerlink\" title=\"三、各个功能的实现\"></a>三、各个功能的实现</h1><h2 id=\"1、图片的制作\"><a href=\"#1、图片的制作\" class=\"headerlink\" title=\"1、图片的制作\"></a>1、图片的制作</h2><p>每个正方形数字图片的大小都为60 * 60像素<br>最后游戏窗体的大小为240 * 300像素、</p>\n<h2 id=\"2、创建2048-h头文件\"><a href=\"#2、创建2048-h头文件\" class=\"headerlink\" title=\"2、创建2048.h头文件\"></a>2、创建2048.h头文件</h2><p>&emsp;&emsp;由于是使用分文件编写的方式(主要是所有函数都写在一个文件里面实在是不方便看)，所以需要创建一个头文件来声明我们需要使用到的库、变量和自定义函数，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">ifndef</span> SMALLGAME</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> SMALLGAME</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;conio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdlib&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;graphics.h&gt; //用到的第一个非C++自带库---&gt;Easyz的图片库</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;ctime&gt;</span></span><br><span class=\"hljs-comment\">//由于分文件编写的</span><br><span class=\"hljs-comment\">//所以注意我们定义的变量都要使用extern类型</span><br><span class=\"hljs-keyword\">extern</span> IMAGE img[<span class=\"hljs-number\">15</span>];<span class=\"hljs-comment\">//存放的是我们的15张图片</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">map</span>[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>];<span class=\"hljs-comment\">//4*4的地图</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">int</span> Imagine_number[<span class=\"hljs-number\">12</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Loadimage</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//加载所有的图片</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DrawMap</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//根据二维数组中的数据来贴上相应的图片</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">KeyDown</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//模拟按键</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">RandNum</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//在地图中随机产生数据</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveRight</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向右走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveLeft</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向左走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveUp</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向上走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveDown</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向下走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GAMEOVER</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//游戏结束</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PLAYERWIN</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//游戏获胜</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ScanMap2</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//扫描判断是否获胜</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ScanMap</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//扫描判断是否游戏结束</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n<h2 id=\"3、加载图片资源\"><a href=\"#3、加载图片资源\" class=\"headerlink\" title=\"3、加载图片资源\"></a>3、加载图片资源</h2><p>Easyx开发的图片库可以进行图片的操作，在使用图片之前，需要加载要使用的图片，一共需要加载15张图，所以直接编写一个加载图片的函数利用循环加载即可，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> _CRT_SECURE_NO_WARNINGS <span class=\"hljs-comment\">//去除内扩增的影响</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Loadimage</span><span class=\"hljs-params\">()</span></span>&#123;  <span class=\"hljs-comment\">//加载所有的图片</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">12</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">char</span> FileName[<span class=\"hljs-number\">200</span>]=&#123;&#125;;<br>\t\t<span class=\"hljs-built_in\">sprintf</span>(FileName,<span class=\"hljs-string\">&quot;%d.jpg&quot;</span>,Imagine_number[i]);<br>\t\tloadimage(img + i,FileName);<br>\t&#125;<br>\tloadimage(img + <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&quot;111.jpg&quot;</span>);<br>\tloadimage(img + <span class=\"hljs-number\">13</span>, <span class=\"hljs-string\">&quot;12345.jpg&quot;</span>);<br>\tloadimage(img + <span class=\"hljs-number\">14</span>, <span class=\"hljs-string\">&quot;444.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>注意：sprintf具有不安全性，如果将一个长度大于原定字符数组大小的字符串存放进字符数组，就会发生越界的现象。可以使用snprintf替换sprintf</p>\n<h2 id=\"4、绘制地图\"><a href=\"#4、绘制地图\" class=\"headerlink\" title=\"4、绘制地图\"></a>4、绘制地图</h2><p>遍历二维数组中的数据，根据二维数组中每个元素的数据来判断应该在某个位置贴上对应的图片，注意需要根据图片的尺寸来计算每个点的x,y坐标。<br>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DrawMap</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//画地图</span><br>\tsetbkcolor(RGB(<span class=\"hljs-number\">244</span>,<span class=\"hljs-number\">215</span>,<span class=\"hljs-number\">215</span>));  <span class=\"hljs-comment\">//设置窗体背景颜色</span><br>\tcleardevice();<span class=\"hljs-comment\">//更新一遍窗体</span><br>\tsettextcolor(WHITE);<span class=\"hljs-comment\">//设置文本颜色</span><br>\tsettextstyle(<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&quot;圆体&quot;</span>);<span class=\"hljs-comment\">//字体大小</span><br>\touttextxy(<span class=\"hljs-number\">50</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-string\">&quot;2048小游戏&quot;</span>);<span class=\"hljs-comment\">//文字内容</span><br>\t<span class=\"hljs-keyword\">int</span> x,y,k;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\tx=<span class=\"hljs-number\">60</span>*j;<span class=\"hljs-comment\">//列</span><br>\t\t\ty=<span class=\"hljs-number\">60</span>*i+<span class=\"hljs-number\">60</span>;<span class=\"hljs-comment\">//行</span><br>\t\t\t<span class=\"hljs-comment\">//printf(&quot;%d %d\\n&quot;,x,y);</span><br>\t\t\t<span class=\"hljs-keyword\">for</span>(k = <span class=\"hljs-number\">0</span>;k &lt; <span class=\"hljs-number\">12</span>;k++)&#123;<span class=\"hljs-comment\">//遍历12张图片</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(Imagine_number[k] == <span class=\"hljs-built_in\">map</span>[i][j])<br>\t\t\t\t<span class=\"hljs-comment\">//判断应该贴哪一张图片</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//退出循环</span><br>\t\t\t&#125;<br>\t\t\tputimage(x,y,img+k);<span class=\"hljs-comment\">//在(x,y)的位置贴上第k张图</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5、在二维数组中产生随机数\"><a href=\"#5、在二维数组中产生随机数\" class=\"headerlink\" title=\"5、在二维数组中产生随机数\"></a>5、在二维数组中产生随机数</h2><p>C++中产生随机数需要使用到随机数函数srand();(包含于cstdlib库中)<br>用法：srand((unsigned int)随机数种子(NULL))<br>若随机数种子保持不变，那么所生成的随机数也不会改变（感觉没说清楚，只能自行理解了）。故此我们一般使用电脑的系统时间作为随机数种子，也就是:</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-function\"><span class=\"hljs-title\">srand</span>((<span class=\"hljs-variable\">unsigned</span> <span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\"><span class=\"hljs-built_in\">time</span></span>(<span class=\"hljs-variable\"><span class=\"hljs-literal\">NULL</span></span>));</span><br></code></pre></td></tr></table></figure>\n<p>由于这里使用到了系统时间，所以需要包含C++的系统库—-&gt;<strong>ctime</strong></p>\n<p>在2048小游戏中，每次产生的随机数为2或4。<br>那么如何产生这种随机数？可以这么做👇</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><code class=\"hljs matlab\">temp=(<span class=\"hljs-built_in\">rand</span>()<span class=\"hljs-comment\">%3) * 2;</span><br>注意:<span class=\"hljs-built_in\">rand</span>() <span class=\"hljs-comment\">% n得到的就是[0,n)的数据</span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;那么不可避免地会生成0这么一个随机数，但我们只需要在生成后判断一次即可，如果是0，那么我们就在其他的区域内继续生成一个随机数。<br>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">RandNum</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//在地图中随机产生数字</span><br>\tsrand((<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>)time(<span class=\"hljs-literal\">NULL</span>));<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j] = (rand()%<span class=\"hljs-number\">3</span>)*<span class=\"hljs-number\">2</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">continue</span>;  <span class=\"hljs-comment\">//如果产生的随机数为0  那么就在其他的区域内继续产生随机数</span><br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6、按键操作\"><a href=\"#6、按键操作\" class=\"headerlink\" title=\"6、按键操作\"></a>6、按键操作</h2><h3 id=\"Ⅰ、数的合并操作\"><a href=\"#Ⅰ、数的合并操作\" class=\"headerlink\" title=\"Ⅰ、数的合并操作\"></a>Ⅰ、数的合并操作</h3><p>&emsp;&emsp;在上下左右的移动过程中，如果移动路径上有可以合并的数，按照规则我们需要进行合并操作；</p>\n<h3 id=\"Ⅱ、数的移动\"><a href=\"#Ⅱ、数的移动\" class=\"headerlink\" title=\"Ⅱ、数的移动\"></a>Ⅱ、数的移动</h3><p>&emsp;&emsp;在移动的过程中，如果某个方块在移动路径上没有数字方块，那么我们就需要对该方块进行移动操作；<br> <figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><code class=\"hljs makefile\">不同方向上的合并和移动操作的代码是有些许不同的，但是其思想都是一样的<br><span class=\"hljs-section\">下面就以按下右键向右移动为例:</span><br></code></pre></td></tr></table></figure><br> <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"> <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br> <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveRight</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;  <span class=\"hljs-comment\">//判断是否可以合并</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>;j &gt;= <span class=\"hljs-number\">0</span>;j--)&#123;  <br>\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//取当前元素的前一个元素</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前的元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(NowKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">// 等于0的时候再去判断是没有意义的</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//列指针移动</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<span class=\"hljs-comment\">//取当前元素的下一个元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//按照规则，每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>;j&gt;=<span class=\"hljs-number\">0</span>;j--)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t\t<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br> &emsp;&emsp;其他三个方向的操作与向右移动类似，不再赘述；此时二维数组中的数据已经发生了更新；（其实如果你不想用图形库的话，可以简单的通过不断的打印二维数组实现类似的效果）更新以后，我们再根据新的数据在对应的位置来贴上对应的图片（可以理解为又覆盖上了一层图片）也就达到了移动的效果。</p>\n<h2 id=\"7、胜局判断\"><a href=\"#7、胜局判断\" class=\"headerlink\" title=\"7、胜局判断\"></a>7、胜局判断</h2><p> &emsp;&emsp;每次按键+打印地图之后对二维数组进行扫描，一旦发现了2048这个数据，那么直接跳到PLAYERWIN()这个函数。<br> <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) <br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> WINNERCHECK;<br>\t\tKeyDown();<span class=\"hljs-comment\">//按下按键</span><br>\t\tDrawMap();<span class=\"hljs-comment\">//打印一遍地图</span><br>\t\tWINNERCHECK = ScanMap2();<br>\t\t<span class=\"hljs-keyword\">if</span> (WINNERCHECK == <span class=\"hljs-number\">1</span>) <br>\t\t&#123;<br>\t\t\tputimage(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, img + <span class=\"hljs-number\">13</span>);<span class=\"hljs-comment\">//贴上游戏获胜的图片</span><br>\t\t\t<span class=\"hljs-keyword\">break</span>; <br>\t\t&#125;<span class=\"hljs-comment\">//游戏获胜</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"8、败局判断\"><a href=\"#8、败局判断\" class=\"headerlink\" title=\"8、败局判断\"></a>8、败局判断</h2><p> &emsp;&emsp;扫描地图，对四个方向尝试移动（只是尝试！没有更新二维数数组中的数据！可以想想该怎么做！），如果有一个方向还可以移动，那么就未达到败局。如果四个方向都已经尝试过且无法移动，那么就已是败局，贴上游戏失败的图片</p>\n<h1 id=\"四、整体代码\"><a href=\"#四、整体代码\" class=\"headerlink\" title=\"四、整体代码\"></a>四、整体代码</h1><p>&emsp;1、头文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">ifndef</span> SMALLGAME</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> SMALLGAME</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;conio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdlib&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;graphics.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;ctime&gt;</span></span><br><span class=\"hljs-keyword\">extern</span> IMAGE img[<span class=\"hljs-number\">15</span>];<br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">map</span>[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">int</span> Imagine_number[<span class=\"hljs-number\">12</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Loadimage</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//加载所有的图片</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DrawMap</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//根据二维数组中的数据来贴上相应的图片</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">KeyDown</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//模拟按键</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">RandNum</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//在地图中随机产生数据</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveRight</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向右走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveLeft</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向左走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveUp</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向上走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveDown</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向下走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GAMEOVER</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PLAYERWIN</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ScanMap1</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ScanMap2</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ScanMap</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n<p>&emsp;2、源文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br><span class=\"hljs-keyword\">int</span> Imagine_number[<span class=\"hljs-number\">12</span>]=&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">64</span>,<span class=\"hljs-number\">128</span>,<span class=\"hljs-number\">256</span>,<span class=\"hljs-number\">512</span>,<span class=\"hljs-number\">1024</span>,<span class=\"hljs-number\">2048</span>&#125;;<br><span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">map</span>[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>]=&#123;<span class=\"hljs-number\">0</span>&#125;;<span class=\"hljs-comment\">//地图默认全部为0</span><br>IMAGE img[<span class=\"hljs-number\">15</span>];<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//主函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\tinitgraph(<span class=\"hljs-number\">240</span>,<span class=\"hljs-number\">300</span>);  <span class=\"hljs-comment\">//创建游戏窗体</span><br>\tLoadimage();<span class=\"hljs-comment\">//加载图片资源</span><br>\tDrawMap();<span class=\"hljs-comment\">//打印一遍默认的地图</span><br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> WINNERCHECK;<br>\t\tKeyDown();<span class=\"hljs-comment\">//按下按键</span><br>\t\tDrawMap();<span class=\"hljs-comment\">//打印一遍地图</span><br>\t\t<span class=\"hljs-keyword\">if</span> (ScanMap() == <span class=\"hljs-literal\">false</span>) &#123;<br>\t\t\tgetchar();<br>\t\t\tGAMEOVER();<br>\t\t\tsystem(<span class=\"hljs-string\">&quot;cls&quot;</span>);<br>\t\t\t<span class=\"hljs-comment\">//putimage(0, 0, img+14);</span><br>\t\t\tgetchar();<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\tWINNERCHECK= ScanMap2();<br>\t\t<span class=\"hljs-keyword\">if</span> (WINNERCHECK== <span class=\"hljs-number\">1</span>) &#123; putimage(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, img + <span class=\"hljs-number\">13</span>); <span class=\"hljs-keyword\">break</span>; &#125;<span class=\"hljs-comment\">//游戏获胜</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">//getchar();//暂停窗体</span><br>\t<span class=\"hljs-comment\">//closegraph();//关闭窗体</span><br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//画地图</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DrawMap</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//画地图</span><br>\tsetbkcolor(RGB(<span class=\"hljs-number\">244</span>,<span class=\"hljs-number\">215</span>,<span class=\"hljs-number\">215</span>));  <span class=\"hljs-comment\">//设置窗体背景颜色</span><br>\tcleardevice();<span class=\"hljs-comment\">//更新一遍窗体</span><br>\tsettextcolor(WHITE);<span class=\"hljs-comment\">//设置文本数据</span><br>\tsettextstyle(<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&quot;楷体&quot;</span>);<br>\touttextxy(<span class=\"hljs-number\">50</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-string\">&quot;2048小游戏&quot;</span>);<br>\t<span class=\"hljs-keyword\">int</span> x,y,k;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\tx=<span class=\"hljs-number\">60</span>*j;<span class=\"hljs-comment\">//列</span><br>\t\t\ty=<span class=\"hljs-number\">60</span>*i+<span class=\"hljs-number\">60</span>;<span class=\"hljs-comment\">//行</span><br>\t\t\t<span class=\"hljs-comment\">//printf(&quot;%d %d\\n&quot;,x,y);</span><br>\t\t\t<span class=\"hljs-keyword\">for</span>(k = <span class=\"hljs-number\">0</span>;k &lt; <span class=\"hljs-number\">12</span>;k++)&#123;<span class=\"hljs-comment\">//遍历12张图片</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(Imagine_number[k] == <span class=\"hljs-built_in\">map</span>[i][j])<span class=\"hljs-comment\">//如果图片的标号等于地图中的数据</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//退出循环</span><br>\t\t\t&#125;<br>\t\t\tputimage(x,y,img+k);<span class=\"hljs-comment\">//在x,y的位置贴上第k章图</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//游戏结束</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GAMEOVER</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tclosegraph();<br>\tinitgraph(<span class=\"hljs-number\">240</span>, <span class=\"hljs-number\">300</span>);  <span class=\"hljs-comment\">//创建游戏窗体</span><br>\tputimage(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, img + <span class=\"hljs-number\">12</span>);<br>\tgetchar();<br>&#125; <br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//模拟按键</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">KeyDown</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> Key = _getch();<span class=\"hljs-comment\">//_getch()可以从键盘接受一个字符且不需要按enter键就可以执行</span><br>\t<span class=\"hljs-keyword\">switch</span>(Key)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;w&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;W&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span>  <span class=\"hljs-number\">72</span>:<br>\t\t\tRandNum();<span class=\"hljs-comment\">//每次移动都会伴随着移动</span><br>\t\t\tMoveUp();<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;s&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;S&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span>  <span class=\"hljs-number\">80</span>:<br>\t\t\tRandNum();<br>\t\t\tMoveDown();\t\t\t<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;A&#x27;</span>: <br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">75</span>:<br>\t\t\tRandNum();<br>\t\t\tMoveLeft();\t\t<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;d&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;D&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">77</span>:<br>\t\t\tRandNum();<br>\t\t\tMoveRight();\t\t<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//加载图片</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> _CRT_SECURE_NO_WARNINGS <span class=\"hljs-comment\">//去掉sprintf内扩增的影响</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Loadimage</span><span class=\"hljs-params\">()</span></span>&#123;  <span class=\"hljs-comment\">//加载所有的图片</span><br>\tloadimage(img + <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&quot;111.jpg&quot;</span>);<br>\tloadimage(img + <span class=\"hljs-number\">13</span>, <span class=\"hljs-string\">&quot;12345.jpg&quot;</span>);<br>\tloadimage(img + <span class=\"hljs-number\">14</span>, <span class=\"hljs-string\">&quot;444.jpg&quot;</span>);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">12</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">char</span> FileName[<span class=\"hljs-number\">200</span>]=&#123;&#125;;<br>\t\t<span class=\"hljs-built_in\">sprintf</span>(FileName,<span class=\"hljs-string\">&quot;%d.jpg&quot;</span>,Imagine_number[i]);<br>\t\tloadimage(img + i,FileName);<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//移动</span><br><span class=\"hljs-comment\">//不同方向的移动</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveRight</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;  <span class=\"hljs-comment\">//判断是否可以合并</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>;j &gt;= <span class=\"hljs-number\">0</span>;j--)&#123;  <br>\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前的元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(NowKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">// 等于0的时候再去判断是没有意义的</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//列指针移动</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<span class=\"hljs-comment\">//取当前元素的下一个元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=-1;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>;j&gt;=<span class=\"hljs-number\">0</span>;j--)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t\t<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveLeft</span><span class=\"hljs-params\">()</span></span>&#123;  <span class=\"hljs-comment\">//向左走</span><br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(NowKey != <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &lt; <span class=\"hljs-number\">4</span>)&#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=4;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &lt; <span class=\"hljs-number\">4</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveUp</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123; <span class=\"hljs-comment\">//i是行 j是列</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] != <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &lt; <span class=\"hljs-number\">4</span>)&#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[k][j] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=4;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i+<span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &lt; <span class=\"hljs-number\">4</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[k][j] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[k][j]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveDown</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>;i &gt;= <span class=\"hljs-number\">0</span>;i--)&#123; <span class=\"hljs-comment\">//i是行 j是列</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(NowKey != <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[k][j] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=-1;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i<span class=\"hljs-number\">-1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[k][j] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[k][j]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//生成随机数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">RandNum</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//在地图中随机产生数字</span><br>\tsrand((<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>)time(<span class=\"hljs-literal\">NULL</span>));<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j] = (rand()%<span class=\"hljs-number\">3</span>)*<span class=\"hljs-number\">2</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">continue</span>;  <span class=\"hljs-comment\">//如果产生的随机数为0  那么就在其他的区域内继续产生随机数</span><br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//败局判断</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ScanMap</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-comment\">/*向右走*/</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;  <span class=\"hljs-comment\">//判断是否可以合并</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>; j &gt;= <span class=\"hljs-number\">0</span>; j--) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前的元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (NowKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 等于0的时候再去判断是没有意义的</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &gt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//列指针移动</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<span class=\"hljs-comment\">//取当前元素的下一个元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey == NowKey) &#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] *= 2;//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][k] = 0;</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=-1;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>; j &gt;= <span class=\"hljs-number\">0</span>; j--) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] = nowkeynext;</span><br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][k] = 0; //非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">/*向左走*/</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (NowKey != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &lt; <span class=\"hljs-number\">4</span>) &#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey == NowKey) &#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">///map[i][j] *= 2;//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][k] = 0;</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=4;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &lt; <span class=\"hljs-number\">4</span>) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] = nowkeynext;</span><br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][k] = 0; //非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">/*向上走*/</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123; <span class=\"hljs-comment\">//i是行 j是列</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &lt; <span class=\"hljs-number\">4</span>) &#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey == NowKey) &#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] *= 2;//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[k][j] = 0;</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=4;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &lt; <span class=\"hljs-number\">4</span>) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[k][j] != <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] = nowkeynext;</span><br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[k][j] = 0; //非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">/*向下走*/</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123; <span class=\"hljs-comment\">//i是行 j是列</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (NowKey != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &gt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey == NowKey) &#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] *= 2;//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[k][j] = 0;</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=-1;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i - <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[k][j] != <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] = nowkeynext;</span><br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[k][j] = 0; //非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (flag == <span class=\"hljs-literal\">false</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//胜局判断</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ScanMap2</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">3</span>; j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">2048</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><p>&emsp;&emsp;进工作室以来第一次写小游戏。这一次写小游戏的过程中收获到了不少新东西：<br>&emsp;&emsp;&emsp;&emsp;1、<strong>Easyx的图形库的使用</strong><br>&emsp;&emsp;&emsp;&emsp;2、随机数的生成<br>&emsp;&emsp;&emsp;&emsp;3、_getch()和getchar()的区别<br>&emsp;&emsp;&emsp;&emsp;4、sprintf()的用法以及其不安全性<br>&emsp;&emsp;学会了Easyx的图形库以后可以学习做其他的小游戏。然后感觉自己还是有很多不会的东西。图书管理系统写了一小半但是感觉没有API的话写出来也没什么意思，等以后学了Java再继续完成吧。这学期剩下的时间好好复习的同时学习一点Linux服务器的知识，看能不能做出一个属于自己的博客吧！<br>&emsp;&emsp;冲冲冲！</p>\n","slug":"SmallGame","updated":"2020-12-11T09:44:59.208Z","comments":true,"link":"","permalink":"http://example.com/2020/12/11/SmallGame/","excerpt":"","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"这是我的第一篇博客","date":"2020-12-10T12:54:02.000Z","path":"2020/12/10/my-first-blog/","text":"My name is Yu Xinrui This is my first blog on Github OK,Bye bye~","raw":"---\ntitle: 这是我的第一篇博客\ncategories: 草稿\ntags: \n\t- C\n\t- Blog\nexcerpt: 博客\ndate: 2020-12-10 20:54:02\ncover: 'https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imgQuietView.png'\n---\n\nMy name is **Yu Xinrui**\n\nThis is my **first blog** on **Github**\n\nOK,Bye bye~","content":"<p>My name is <strong>Yu Xinrui</strong></p>\n<p>This is my <strong>first blog</strong> on <strong>Github</strong></p>\n<p>OK,Bye bye~</p>\n","slug":"my-first-blog","updated":"2020-12-11T09:45:03.488Z","comments":true,"link":"","permalink":"http://example.com/2020/12/10/my-first-blog/","excerpt":"博客","categories":[{"name":"草稿","slug":"草稿","permalink":"http://example.com/categories/%E8%8D%89%E7%A8%BF/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/tags/Blog/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]}]