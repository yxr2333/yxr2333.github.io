[{"title":"Nextcloud","date":"2020-12-20T03:40:48.000Z","path":"2020/12/20/Nextcloud/","text":"项目：nextcloud云盘 成品：mycloud.iloveyxr.top 最近尝试的，在服务器上尝试搭建一个 类似于百度云的个人云盘 效果还可以，毕竟类似于一种傻瓜式的操作 上传速度倒是还可以，取决于个人的网速 但是下载速度就让我知道：还真的不能怪某度云 这玩意儿速度真的上不来 下面说说遇到的问题吧 1、搭建的过程参考知乎文章：https://zhuanlan.zhihu.com/p/38485411 大致分为以下几个步骤 1、搭建 LNMP环境 (nginx+php+mysql+linux) 2、下载nextcloud安装文件 3、推荐使用宝塔面板），点击创建网站 ​ ps:如果是使用ip访问的话可以设置为默认站点。 4、将安装文件上传到网站的目录下面 5、访问http://yourip/setup-nextcloud.php来设置你的管理员信息 数据库默认是SQLite，不用设置，但如果是使用SQl数据库的话就要输入数据库名之类的信息了 2、遇到的问题1、给网站设置二级域名 ​ 首先在阿里云的域名管理那解析好一个二级域名（如何解析可以百度一下，比如我的域名就是mycloud.iloveyxr.top） ​ 然后在宝塔面板里面把域名添加到你的网站里面去，之后就可以通过域名访问网站了 2、404 not found nginx ​ 在宝塔面板里面点击域名跳转的时候发现会提示 404 not found nginx, 但是在浏览器中输入域名却是可以正常访问的，可能是涉及到了底层的一些知识，目前还不是很清楚具体的原因是什么，在哪里出错了。 3、通过域名访问的时候提示该域名不安全 ​ 这是因为Nextcloud有一个可以访问的名单，在网站的目录下有/nextcloud/config/config.php,编辑这个文件，在array后面按照格式添加自己的域名就可以了。","raw":"---\ntitle: Nextcloud\ndate: 2020-12-20 11:40:48\ntags:\n\t- web\n\t- cloud\ncategories: web\n---\n\n-------------\n\n**项目：nextcloud云盘**\n\n**成品：**[mycloud.iloveyxr.top]()\n\n-----------\n\n最近尝试的，在服务器上尝试搭建一个 类似于百度云的**个人云盘**\n\n**效果还可以，~~毕竟类似于一种傻瓜式的操作~~**\n\n上传速度倒是还可以，取决于个人的网速\n\n但是下载速度就让我知道：**还真的不能怪某度云**\n\n这玩意儿速度真的上不来\n\n**下面说说遇到的问题吧**\n\n------------------------\n\n# 1、搭建的过程\n\n参考知乎文章：https://zhuanlan.zhihu.com/p/38485411\n\n~~大致分为以下几个步骤~~\n\n1、搭建 LNMP环境 (nginx+php+mysql+linux)\n\n2、[下载nextcloud安装文件](https://download.nextcloud.com/server/installer/setup-nextcloud.php)\n\n3、推荐使用宝塔面板），点击创建网站\n\n​\t~~ps:如果是使用ip访问的话可以设置为默认站点~~。\n\n4、将安装文件上传到网站的目录下面\n\n5、访问http://yourip/setup-nextcloud.php来设置你的管理员信息\n\n~~数据库默认是SQLite，不用设置，但如果是使用SQl数据库的话就要输入数据库名之类的信息了~~\n\n## 2、遇到的问题\n\n**1、给网站设置二级域名**\n\n​\t\t首先在阿里云的域名管理那解析好一个**二级域名**（如何解析可以百度一下，比如我的域名就是[mycloud.iloveyxr.top](http://47.102.198.114/nextcloud/index.php/)）\n\n​\t\t然后在宝塔面板里面把域名添加到你的网站里面去，之后就可以通过域名访问网站了\n\n**2、404 not found nginx**\n\n​\t\t在宝塔面板里面点击域名跳转的时候发现会提示 ~~404 not found nginx~~, 但是在浏览器中输入域名却是可以正常访问的，可能是涉及到了底层的一些知识，目前还不是很清楚具体的原因是什么，在哪里出错了。\n\n**3、通过域名访问的时候提示该域名不安全**\n\n​\t\t这是因为Nextcloud有一个可以访问的名单，在网站的目录下有/nextcloud/config/config.php,编辑这个文件，在array后面按照格式添加自己的域名就可以了。\n\n![QQ截图20201220113932.png](https://i.loli.net/2020/12/20/JdtTUAiZ7goLVuK.png)\n\n","content":"<hr>\n<p><strong>项目：nextcloud云盘</strong></p>\n<p><strong>成品：</strong><a href=\"\">mycloud.iloveyxr.top</a></p>\n<hr>\n<p>最近尝试的，在服务器上尝试搭建一个 类似于百度云的<strong>个人云盘</strong></p>\n<p><strong>效果还可以，<del>毕竟类似于一种傻瓜式的操作</del></strong></p>\n<p>上传速度倒是还可以，取决于个人的网速</p>\n<p>但是下载速度就让我知道：<strong>还真的不能怪某度云</strong></p>\n<p>这玩意儿速度真的上不来</p>\n<p><strong>下面说说遇到的问题吧</strong></p>\n<hr>\n<h1 id=\"1、搭建的过程\"><a href=\"#1、搭建的过程\" class=\"headerlink\" title=\"1、搭建的过程\"></a>1、搭建的过程</h1><p>参考知乎文章：<a href=\"https://zhuanlan.zhihu.com/p/38485411\">https://zhuanlan.zhihu.com/p/38485411</a></p>\n<p><del>大致分为以下几个步骤</del></p>\n<p>1、搭建 LNMP环境 (nginx+php+mysql+linux)</p>\n<p>2、<a href=\"https://download.nextcloud.com/server/installer/setup-nextcloud.php\">下载nextcloud安装文件</a></p>\n<p>3、推荐使用宝塔面板），点击创建网站</p>\n<p>​    <del>ps:如果是使用ip访问的话可以设置为默认站点</del>。</p>\n<p>4、将安装文件上传到网站的目录下面</p>\n<p>5、访问<a href=\"http://yourip/setup-nextcloud.php%E6%9D%A5%E8%AE%BE%E7%BD%AE%E4%BD%A0%E7%9A%84%E7%AE%A1%E7%90%86%E5%91%98%E4%BF%A1%E6%81%AF\">http://yourip/setup-nextcloud.php来设置你的管理员信息</a></p>\n<p><del>数据库默认是SQLite，不用设置，但如果是使用SQl数据库的话就要输入数据库名之类的信息了</del></p>\n<h2 id=\"2、遇到的问题\"><a href=\"#2、遇到的问题\" class=\"headerlink\" title=\"2、遇到的问题\"></a>2、遇到的问题</h2><p><strong>1、给网站设置二级域名</strong></p>\n<p>​        首先在阿里云的域名管理那解析好一个<strong>二级域名</strong>（如何解析可以百度一下，比如我的域名就是<a href=\"http://47.102.198.114/nextcloud/index.php/\">mycloud.iloveyxr.top</a>）</p>\n<p>​        然后在宝塔面板里面把域名添加到你的网站里面去，之后就可以通过域名访问网站了</p>\n<p><strong>2、404 not found nginx</strong></p>\n<p>​        在宝塔面板里面点击域名跳转的时候发现会提示 <del>404 not found nginx</del>, 但是在浏览器中输入域名却是可以正常访问的，可能是涉及到了底层的一些知识，目前还不是很清楚具体的原因是什么，在哪里出错了。</p>\n<p><strong>3、通过域名访问的时候提示该域名不安全</strong></p>\n<p>​        这是因为Nextcloud有一个可以访问的名单，在网站的目录下有/nextcloud/config/config.php,编辑这个文件，在array后面按照格式添加自己的域名就可以了。</p>\n<p><img src=\"https://i.loli.net/2020/12/20/JdtTUAiZ7goLVuK.png\" alt=\"QQ截图20201220113932.png\"></p>\n","slug":"Nextcloud","updated":"2020-12-20T04:05:18.766Z","comments":true,"link":"","permalink":"http://example.com/2020/12/20/Nextcloud/","excerpt":"","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"cloud","slug":"cloud","permalink":"http://example.com/tags/cloud/"}]},{"title":"如何使用Github托管文件夹？","date":"2020-12-12T12:46:24.000Z","path":"2020/12/12/github4/","text":"如何使用Github托管文件夹？一、首先在桌面上新建文件夹 二、右键使用Git Bash打开 三、初始化 git init 四、将文件add到缓存区(stage) git add &quot;filename&quot; 五、将文件commit到本地仓库 git commit -m &#x27;备注信息&#x27;# commit会将暂存区里所有的文件都上传本地仓库(respository)中# 如果没有在commit后面添加备注信息，那么会自动打开一个txt文档让用户使用vim编辑器添加备注信息 六、关联本地仓库 git remote add origin git@github.com:用户名/仓库名.git#用户名：Github的用户名#仓库名：该文件夹对应的GitHub仓库名 七、push到远程仓库 git push -u origin master# 如果上述操作报错 可以执行以下命令👇git pull --rebase origin master# 然后再执行 git push -u origin master 会遇到的问题： 1、如果需要上传大文件怎么办？ ​ 解决方法：上传的文件如果大于100M那么就需要下载git lts 软件来上传 2、如何查看缓存区中有哪些文件？ ​ 解决方法：输入命令 git cherry -v 即可查询到 3、如果add后想取消上传该如何处理？ ​ 解决方法：输入命令 git reset HEAD~，就可以取消上传了。如果想再次上传，只需要再执行一次commit操作就可以了 4、常用的指令 ​ git init 初始化 ​ git add 添加进暂存区 ​ git commit 上传到本地仓库 ​ git push -u orgin master 上传到github仓库 ​ git cherry -v 查看本地仓库中暂时还未上传的","raw":"---\ntitle: 如何使用Github托管文件夹？\ndate: 2020-12-12 20:46:24\ncategories: Github知识\ntags:\n\t- Github\n\t- Git\n\t- summary\n---\n\n# 如何使用Github托管文件夹？\n\n**一、首先在桌面上新建文件夹**\n\n**二、右键使用Git Bash打开**\n\n**三、初始化**\n\n```nginx\ngit init\n```\n\n\n\n**四、将文件add到缓存区(stage)**\n\n```nginx\ngit add \"filename\"\n```\n\n\n\n**五、将文件commit到本地仓库**\n\n```nginx\ngit commit -m '备注信息'\n\n\n# commit会将暂存区里所有的文件都上传本地仓库(respository)中\n\n# 如果没有在commit后面添加备注信息，那么会自动打开一个txt文档让用户使用vim编辑器添加备注信息\n\n```\n\n\n\n**六、关联本地仓库**\n\n```nginx\ngit remote add origin git@github.com:用户名/仓库名.git\n\n#用户名：Github的用户名\n#仓库名：该文件夹对应的GitHub仓库名\n```\n\n\n\n**七、push到远程仓库**\n\n```nginx\ngit push -u origin master\n\n# 如果上述操作报错  可以执行以下命令👇\ngit pull --rebase origin master\n# 然后再执行  \ngit push -u origin master\n\n```\n\n\n\n**~~会遇到的问题：~~**\n\n**1、如果需要上传大文件怎么办？**\n\n​\t**解决方法**：上传的文件如果大于100M那么就需要下载git lts 软件来上传\n\n**2、如何查看缓存区中有哪些文件？**\n\n​\t**解决方法**：输入命令  git cherry -v 即可查询到\n\n**3、如果add后想取消上传该如何处理？**\n\n​\t**解决方法**：输入命令 git reset HEAD~，就可以取消上传了。如果想再次上传，只需要再执行一次commit操作就可以了\n\n**4、常用的指令**\n\n​\tgit init\t初始化\n\n​\tgit add\t添加进暂存区\n\n​\tgit commit\t上传到本地仓库\n\n​\tgit push -u orgin master\t上传到github仓库\n\n​\tgit cherry -v\t查看本地仓库中暂时还未上传的","content":"<h1 id=\"如何使用Github托管文件夹？\"><a href=\"#如何使用Github托管文件夹？\" class=\"headerlink\" title=\"如何使用Github托管文件夹？\"></a>如何使用Github托管文件夹？</h1><p><strong>一、首先在桌面上新建文件夹</strong></p>\n<p><strong>二、右键使用Git Bash打开</strong></p>\n<p><strong>三、初始化</strong></p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">git</span> init<br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>四、将文件add到缓存区(stage)</strong></p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">git</span> add <span class=\"hljs-string\">&quot;filename&quot;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>五、将文件commit到本地仓库</strong></p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">git</span> commit -m <span class=\"hljs-string\">&#x27;备注信息&#x27;</span><br><br><br><span class=\"hljs-comment\"># commit会将暂存区里所有的文件都上传本地仓库(respository)中</span><br><br><span class=\"hljs-comment\"># 如果没有在commit后面添加备注信息，那么会自动打开一个txt文档让用户使用vim编辑器添加备注信息</span><br><br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>六、关联本地仓库</strong></p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">git</span> remote add origin git@github.com:用户名/仓库名.git<br><br><span class=\"hljs-comment\">#用户名：Github的用户名</span><br><span class=\"hljs-comment\">#仓库名：该文件夹对应的GitHub仓库名</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>七、push到远程仓库</strong></p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">git</span> push -u origin master<br><br><span class=\"hljs-comment\"># 如果上述操作报错  可以执行以下命令👇</span><br>git pull --rebase origin master<br><span class=\"hljs-comment\"># 然后再执行  </span><br>git push -u origin master<br><br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong><del>会遇到的问题：</del></strong></p>\n<p><strong>1、如果需要上传大文件怎么办？</strong></p>\n<p>​    <strong>解决方法</strong>：上传的文件如果大于100M那么就需要下载git lts 软件来上传</p>\n<p><strong>2、如何查看缓存区中有哪些文件？</strong></p>\n<p>​    <strong>解决方法</strong>：输入命令  git cherry -v 即可查询到</p>\n<p><strong>3、如果add后想取消上传该如何处理？</strong></p>\n<p>​    <strong>解决方法</strong>：输入命令 git reset HEAD~，就可以取消上传了。如果想再次上传，只需要再执行一次commit操作就可以了</p>\n<p><strong>4、常用的指令</strong></p>\n<p>​    git init    初始化</p>\n<p>​    git add    添加进暂存区</p>\n<p>​    git commit    上传到本地仓库</p>\n<p>​    git push -u orgin master    上传到github仓库</p>\n<p>​    git cherry -v    查看本地仓库中暂时还未上传的</p>\n","slug":"github4","updated":"2020-12-13T04:46:23.716Z","comments":true,"link":"","permalink":"http://example.com/2020/12/12/github4/","excerpt":"","categories":[{"name":"Github知识","slug":"Github知识","permalink":"http://example.com/categories/Github%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"summary","slug":"summary","permalink":"http://example.com/tags/summary/"}]},{"title":"如何在Github上上传大文件?","date":"2020-12-12T12:45:45.000Z","path":"2020/12/12/github3/","text":"如何在Github上上传大文件?工具：Git LFS （Git largefiles) 下载链接： 一、安装git lfs git lfs install 二、让lfs跟踪需要被上传的文件 git lfs track &quot;filename&quot; 三、添加配置文件.gitattributes git add .gitattributes 四、上传 git push -u origin master","raw":"---\ntitle: 如何在Github上上传大文件?\ndate: 2020-12-12 20:45:45\ncategories: Github知识\ntags:\n\t- Github\n\t- Git\n\t- summary\n---\n\n# 如何在Github上上传大文件?\n\n**工具：Git LFS （Git largefiles)**\n\n**下载链接：[](https://git-lfs.github.com/)**\n\n一、安装git lfs\n\n```css\ngit lfs install\n```\n\n二、让lfs跟踪需要被上传的文件\n\n```css\ngit lfs track \"filename\"\n```\n\n三、添加配置文件.gitattributes\n\n```css\ngit add .gitattributes\n```\n\n四、上传\n\n```css\ngit push -u origin master\n```\n\n","content":"<h1 id=\"如何在Github上上传大文件\"><a href=\"#如何在Github上上传大文件\" class=\"headerlink\" title=\"如何在Github上上传大文件?\"></a>如何在Github上上传大文件?</h1><p><strong>工具：Git LFS （Git largefiles)</strong></p>\n<p><strong>下载链接：<a href=\"https://git-lfs.github.com/\"></a></strong></p>\n<p>一、安装git lfs</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">git</span> <span class=\"hljs-selector-tag\">lfs</span> <span class=\"hljs-selector-tag\">install</span><br></code></pre></td></tr></table></figure>\n\n<p>二、让lfs跟踪需要被上传的文件</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">git</span> <span class=\"hljs-selector-tag\">lfs</span> <span class=\"hljs-selector-tag\">track</span> &quot;<span class=\"hljs-selector-tag\">filename</span>&quot;<br></code></pre></td></tr></table></figure>\n\n<p>三、添加配置文件.gitattributes</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">git</span> <span class=\"hljs-selector-tag\">add</span> <span class=\"hljs-selector-class\">.gitattributes</span><br></code></pre></td></tr></table></figure>\n\n<p>四、上传</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">git</span> <span class=\"hljs-selector-tag\">push</span> <span class=\"hljs-selector-tag\">-u</span> <span class=\"hljs-selector-tag\">origin</span> <span class=\"hljs-selector-tag\">master</span><br></code></pre></td></tr></table></figure>\n\n","slug":"github3","updated":"2020-12-12T12:46:17.612Z","comments":true,"link":"","permalink":"http://example.com/2020/12/12/github3/","excerpt":"","categories":[{"name":"Github知识","slug":"Github知识","permalink":"http://example.com/categories/Github%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"summary","slug":"summary","permalink":"http://example.com/tags/summary/"}]},{"title":"如何创建SSH密钥？","date":"2020-12-12T12:45:01.000Z","path":"2020/12/12/github2/","text":"如何创建SSH密钥？一、首先在本地生成SSH key ​ 1、右键文件夹，使用Git Bash Here打开 ​ 2、绑定自己的用户名和邮箱 ​ git config --global user.name &quot;Your name&quot;# 设置你的名字git config --global user.email &quot;Your email&quot;# 设置你的邮箱# 建议名字和邮箱与Github的用户名和邮箱保持相同 ​ 3、检查自己是否已经生成密钥：👇 ​ 在本地C:\\Users\\Administrator.ssh查看 ​ 4、如果没有的话使用以下指令生成：👇 ssh-keygen -t rsa -C &quot;Your email&quot;# 连按3次回车即可 ​ 5、生成以后在C:\\Users\\Administrator.ssh里面找到id_rsa.pub 文件，使用记事本打开，Ctrl + A/C/V，得到生成的SSH公钥 二、为Github账号设置SSH key ​ 1、进入Github找到settings ​ 2、然后打开SSH key —–&gt; Add SSH key ​ 3、标题最好和所建仓库的名字一样 ​ 4、将复制的密钥粘贴，点击Add key即可","raw":"---\ntitle: 如何创建SSH密钥？\ndate: 2020-12-12 20:45:01\ncategories: Github知识\ntags:\n\t- Github\n\t- Git\n\t- summary\n---\n\n# 如何创建SSH密钥？\n\n**一、首先在本地生成SSH key**\n\n​\t1、右键文件夹，使用Git Bash Here打开\n\n​\t2、绑定自己的用户名和邮箱\n\n​\t\n\n```nginx\ngit config --global user.name \"Your name\"\n# 设置你的名字\ngit config --global user.email \"Your email\"\n# 设置你的邮箱\n\n# 建议名字和邮箱与Github的用户名和邮箱保持相同\n```\n\n​\t3、检查自己是否已经生成密钥：👇\n\n​\t\t在本地C:\\Users\\Administrator.ssh查看\n\n​\t4、如果没有的话使用以下指令生成：👇\n\n```nginx\nssh-keygen -t rsa -C \"Your email\"\n\n# 连按3次回车即可\n```\n\n​\t5、生成以后在C:\\Users\\Administrator.ssh里面找到**id_rsa.pub** 文件，使用记事本打开，Ctrl + A/C/V，得到生成的SSH公钥\n\n**二、为Github账号设置SSH key**\n\n​\t1、进入Github找到settings\n\n​\t2、然后打开SSH key   ----->  Add SSH key\n\n​\t3、标题最好和所建仓库的名字一样\n\n​\t4、将复制的密钥粘贴，点击Add key即可\n\n","content":"<h1 id=\"如何创建SSH密钥？\"><a href=\"#如何创建SSH密钥？\" class=\"headerlink\" title=\"如何创建SSH密钥？\"></a>如何创建SSH密钥？</h1><p><strong>一、首先在本地生成SSH key</strong></p>\n<p>​    1、右键文件夹，使用Git Bash Here打开</p>\n<p>​    2、绑定自己的用户名和邮箱</p>\n<p>​    </p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">git</span> config --global user.name <span class=\"hljs-string\">&quot;Your name&quot;</span><br><span class=\"hljs-comment\"># 设置你的名字</span><br>git config --global user.email <span class=\"hljs-string\">&quot;Your email&quot;</span><br><span class=\"hljs-comment\"># 设置你的邮箱</span><br><br><span class=\"hljs-comment\"># 建议名字和邮箱与Github的用户名和邮箱保持相同</span><br></code></pre></td></tr></table></figure>\n\n<p>​    3、检查自己是否已经生成密钥：👇</p>\n<p>​        在本地C:\\Users\\Administrator.ssh查看</p>\n<p>​    4、如果没有的话使用以下指令生成：👇</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><code class=\"hljs nginx\">ssh-keygen -t rsa -C &quot;Your email&quot;<br><br><span class=\"hljs-comment\"># 连按3次回车即可</span><br></code></pre></td></tr></table></figure>\n\n<p>​    5、生成以后在C:\\Users\\Administrator.ssh里面找到<strong>id_rsa.pub</strong> 文件，使用记事本打开，Ctrl + A/C/V，得到生成的SSH公钥</p>\n<p><strong>二、为Github账号设置SSH key</strong></p>\n<p>​    1、进入Github找到settings</p>\n<p>​    2、然后打开SSH key   —–&gt;  Add SSH key</p>\n<p>​    3、标题最好和所建仓库的名字一样</p>\n<p>​    4、将复制的密钥粘贴，点击Add key即可</p>\n","slug":"github2","updated":"2020-12-12T12:45:37.679Z","comments":true,"link":"","permalink":"http://example.com/2020/12/12/github2/","excerpt":"","categories":[{"name":"Github知识","slug":"Github知识","permalink":"http://example.com/categories/Github%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"summary","slug":"summary","permalink":"http://example.com/tags/summary/"}]},{"title":"借助Git搭建博客","date":"2020-12-12T12:40:57.000Z","path":"2020/12/12/github/","text":"借助Git搭建博客学习来源：https://aoboxia.github.io/2019/10/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ 学习作品：https://yxr2333.github.io/ Github是代码托管仓库 Git是一种工具 在本地运行hexo网站的操作右键网站所在文件夹 使用Git Bash打开hexo clean//清空缓存hexo generate//根据markdown生成相应的资源文件hexo server//在本地运行hexo服务在本地运行起hexo服务以后，我们可以在浏览器中使用 http://localhost:4000 进入我们的博客页面 1、从本地更新网站配置： hexo g -d 2、更新主题配置：在网站文件夹根目录中找到themes，双击进入。打开 _config.yml 文件 修改其中相应的配置信息即可 3、新建一篇博客 右键网站的文件夹，使用Git Bash打开输入hexo new &quot;博客名&quot;然后此时就可以在source/_posts目录下看到刚刚创建的 &quot;博客名&quot;.md文件之后就只用在这个md文件中使用markdown编写即可编写完成后 hexo g -d 同步到Github上即可发布一篇新博客似乎此md文件并不能使用中文字符，会导致其他配置文件出现乱码错误最后进行同步其实md文件也不用使用中文名字，只用在title中输入我们想要的名字就可以了 4、新博客的格式规范 ​ titile: xxxx ​ categoried: xxxx —-&gt;类别 ​ date: xxxx ———&gt;日期 ​ tags: ———&gt;标签 ​ - xxx ​ excerpt: xxx ——–&gt;介绍 5、使用账号密码登录Github deploy: type: &#x27;git&#x27; repo: https://github.com/yxr2333/yxr2333.github.io.git #Github仓库的Https地址 branch: master# 这样会使用账号密码进行登录，每次登录都需要输入账号和密码 6、使用SSH密钥登录Github deploy: type: &#x27;git&#x27; repo: git@github.com:yxr2333/yxr2333.github.io.git #Github仓库的SSH地址 branch: master# 这样操作的话就会需要创建一个SSH密钥并在设置中上传此密钥，具体操作见如何创建SSH密钥","raw":"---\ntitle: 借助Git搭建博客\ndate: 2020-12-12 20:40:57\ncategories: Github知识\ntags:\n\t- Github\n\t- Git\n\t- summary\n---\n\n# 借助Git搭建博客\n\n**学习来源**：https://aoboxia.github.io/2019/10/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\n\n**学习作品**：https://yxr2333.github.io/\n\n~~**Github是代码托管仓库**~~\n\n~~**Git是一种工具**~~\n\n```\n在本地运行hexo网站的操作\n右键网站所在文件夹 使用Git Bash打开\nhexo clean//清空缓存\nhexo generate//根据markdown生成相应的资源文件\nhexo server//在本地运行hexo服务\n在本地运行起hexo服务以后，我们可以在浏览器中使用 http://localhost:4000 进入我们的博客页面\n```\n\n\n\n1、从本地更新网站配置： hexo g -d\n\n2、更新主题配置：在网站文件夹根目录中找到themes，双击进入。打开 _config.yml 文件 修改其中相应的配置信息即可\n\n3、新建一篇博客\n\n```\n右键网站的文件夹，使用Git Bash打开\n输入hexo new \"博客名\"\n然后此时就可以在source/_posts目录下看到刚刚创建的 \"博客名\".md文件\n之后就只用在这个md文件中使用markdown编写即可\n编写完成后 hexo g -d 同步到Github上即可发布一篇新博客\n\n似乎此md文件并不能使用中文字符，会导致其他配置文件出现乱码错误最后进行同步\n其实md文件也不用使用中文名字，只用在title中输入我们想要的名字就可以了\n```\n\n4、新博客的格式规范\n\n​\ttitile: xxxx\n\n​\tcategoried: xxxx   ---->类别\n\n​\tdate: xxxx        --------->日期\n\n​\ttags:                  --------->标签\n\n​\t\t\t- xxx \n\n​\texcerpt: xxx      -------->介绍\n\n\n\n5、使用账号密码登录Github\n\n```yaml\ndeploy:\n\ttype: 'git'\n\trepo: https://github.com/yxr2333/yxr2333.github.io.git  #Github仓库的Https地址\n\tbranch: master\n# 这样会使用账号密码进行登录，每次登录都需要输入账号和密码\n```\n\n\n\n6、使用SSH密钥登录Github\n\n```yaml\ndeploy:\n\ttype: 'git'\n\trepo: git@github.com:yxr2333/yxr2333.github.io.git  #Github仓库的SSH地址\n\tbranch: master\n# 这样操作的话就会需要创建一个SSH密钥并在设置中上传此密钥，具体操作见如何创建SSH密钥\n```\n\n","content":"<h1 id=\"借助Git搭建博客\"><a href=\"#借助Git搭建博客\" class=\"headerlink\" title=\"借助Git搭建博客\"></a>借助Git搭建博客</h1><p><strong>学习来源</strong>：<a href=\"https://aoboxia.github.io/2019/10/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">https://aoboxia.github.io/2019/10/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</a></p>\n<p><strong>学习作品</strong>：<a href=\"https://yxr2333.github.io/\">https://yxr2333.github.io/</a></p>\n<p><del><strong>Github是代码托管仓库</strong></del></p>\n<p><del><strong>Git是一种工具</strong></del></p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><code class=\"hljs verilog\">在本地运行hexo网站的操作<br>右键网站所在文件夹 使用Git Bash打开<br>hexo clean<span class=\"hljs-comment\">//清空缓存</span><br>hexo <span class=\"hljs-keyword\">generate</span><span class=\"hljs-comment\">//根据markdown生成相应的资源文件</span><br>hexo server<span class=\"hljs-comment\">//在本地运行hexo服务</span><br>在本地运行起hexo服务以后，我们可以在浏览器中使用 http:<span class=\"hljs-comment\">//localhost:4000 进入我们的博客页面</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>1、从本地更新网站配置： hexo g -d</p>\n<p>2、更新主题配置：在网站文件夹根目录中找到themes，双击进入。打开 _config.yml 文件 修改其中相应的配置信息即可</p>\n<p>3、新建一篇博客</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"code\"><pre><code class=\"hljs dos\">右键网站的文件夹，使用Git Bash打开<br>输入hexo new &quot;博客名&quot;<br>然后此时就可以在source/_posts目录下看到刚刚创建的 &quot;博客名&quot;.<span class=\"hljs-built_in\">md</span>文件<br>之后就只用在这个<span class=\"hljs-built_in\">md</span>文件中使用markdown编写即可<br>编写完成后 hexo g -d 同步到Github上即可发布一篇新博客<br><br>似乎此<span class=\"hljs-built_in\">md</span>文件并不能使用中文字符，会导致其他配置文件出现乱码错误最后进行同步<br>其实<span class=\"hljs-built_in\">md</span>文件也不用使用中文名字，只用在<span class=\"hljs-built_in\">title</span>中输入我们想要的名字就可以了<br></code></pre></td></tr></table></figure>\n\n<p>4、新博客的格式规范</p>\n<p>​    titile: xxxx</p>\n<p>​    categoried: xxxx   —-&gt;类别</p>\n<p>​    date: xxxx        ———&gt;日期</p>\n<p>​    tags:                  ———&gt;标签</p>\n<p>​            - xxx </p>\n<p>​    excerpt: xxx      ——–&gt;介绍</p>\n<p>5、使用账号密码登录Github</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">deploy:</span><br>\t<span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">&#x27;git&#x27;</span><br>\t<span class=\"hljs-attr\">repo:</span> <span class=\"hljs-string\">https://github.com/yxr2333/yxr2333.github.io.git</span>  <span class=\"hljs-comment\">#Github仓库的Https地址</span><br>\t<span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">master</span><br><span class=\"hljs-comment\"># 这样会使用账号密码进行登录，每次登录都需要输入账号和密码</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>6、使用SSH密钥登录Github</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">deploy:</span><br>\t<span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">&#x27;git&#x27;</span><br>\t<span class=\"hljs-attr\">repo:</span> <span class=\"hljs-string\">git@github.com:yxr2333/yxr2333.github.io.git</span>  <span class=\"hljs-comment\">#Github仓库的SSH地址</span><br>\t<span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">master</span><br><span class=\"hljs-comment\"># 这样操作的话就会需要创建一个SSH密钥并在设置中上传此密钥，具体操作见如何创建SSH密钥</span><br></code></pre></td></tr></table></figure>\n\n","slug":"github","updated":"2020-12-12T12:44:47.549Z","comments":true,"link":"","permalink":"http://example.com/2020/12/12/github/","excerpt":"","categories":[{"name":"Github知识","slug":"Github知识","permalink":"http://example.com/categories/Github%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"summary","slug":"summary","permalink":"http://example.com/tags/summary/"}]},{"title":"迷宫中的BFS和DFS问题","date":"2020-12-11T10:11:22.000Z","path":"2020/12/11/sousuo/","text":"迷宫中的BFS和DFS问题前言搜索算法是一种较为常见且基础的算法最新在做迷宫问题的时候学习了深度优先搜索和广度优先搜索写一个博客来总结一下 也方便以后自己复习 一、深度优先算法1）简介深度优先算法（Depth-First-Search），可以简称为DFS，是从一个点出发，通过函数的递归调用，不断地寻找下一个点。如果拓展出来的这个点已经找到了我们所需要的解，那么就开始递归返回到上一个点，如果上一个点不能再继续拓展出新的点，那么就需要递归返回到其父亲节点。不断地判断下去，最终可以得到我们的最优解。 2）实例—-&gt;迷宫问题Description： 小明迷路了，你可以帮他回家吗 Input: 第一行，输入m,n，表示该迷宫有m行n列（m&lt;=85,n&lt;=85） 之后输入一个m*n的矩阵 ’S‘ 表示 起点 ‘E’ 表示终点 output:输出从起点走到终点需要的最短步数min如果没有找到任何一个可行解，打印Sad思路: 从起始点开始扩展可能的点，每拓展出来一个点，在标记数组Book中将其置真值表示已经走过，在递归返回的时候不要忘记将这个点置假，因为其他的点可能会拓展到这个点上来。 代码 #include &lt;iostream&gt;#define N 90using namespace std;char map[N+1][N+1];int book[N+1][N+1]; //标记地图中每个点的状态int final_x,final_y; int _min=99999999; //记录最后的最小步数int m=0,n=0;int next[5][2]=&#123;&#123;0,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;//方向数组void dfs(int x,int y,int sum)&#123; //如果已经到达回家的路 int xr,yr; if(x == final_x &amp;&amp; y == final_y)&#123; if(sum &lt; _min) _min = sum;//如果这条路线的 //最小步数小于当前记录的最小步数 //就更新 return; &#125; for(int i = 1;i&lt;=4;i++)&#123; xr=x+next[i][0]; yr=y+next[i][1]; if(xr &lt; 1 || xr &gt; m || yr &lt; 1 || yr &gt; n) continue; if(book[xr][yr] == 0 &amp;&amp; map[xr][yr] == &#x27;0&#x27;)&#123; book[xr][yr]=1; dfs(xr,yr,sum+1); book[xr][yr]=0; //另一条路可能会经过(xr,yr) //这个点，所以需要将(xr,yr)这个点置0 &#125; &#125; return;&#125;int main()&#123; int beginx,beginy; int sum=0; cin&gt;&gt;m&gt;&gt;n; for(int i = 1;i&lt;=m;i++) for(int j = 1;j&lt;=n;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j] == &#x27;S&#x27;)&#123; beginx=i; beginy=j; map[i][j] = &#x27;0&#x27;; &#125; else if(map[i][j] == &#x27;E&#x27;)&#123; final_x=i; final_y=j; map[i][j] = &#x27;0&#x27;; &#125; &#125; book[beginx][beginy]=1; dfs(beginx,beginy,sum); if(_min == 99999999) cout&lt;&lt;&quot;Sad&quot;; //如果没有可行解 打印Sad else cout&lt;&lt;_min; //cout&lt;&lt;_min; return 0;&#125; 3）深搜的缺点①、当数据量太大时，深搜的递归层数太深，容易爆栈。②、深搜的空间复杂度很小，但时间复杂度很高。 **tips:深搜一般用于棋盘问题 END~ 二、广度优先搜索1）简介广度优先搜索，一般称为宽度优先搜索(Breadth First Search),简称BFS。是一种层层拓展的搜索算法。每一次都向下拓展一级，从而完成对整个图(或关系)的遍历。比如：你需要寻找某一个人，这时候就先需要向你的朋友询问，那么你的朋友就属于一级关系，而如果你的朋友中无法找到这个人。那么就需要从朋友的朋友中寻找，朋友的朋友即为二级关系，一层层拓展，直到找到需要找到的人。 2）实例—-&gt;迷宫问题Description： 小明迷路了，你可以帮他回家吗 Input: 第一行，输入m,n，表示该迷宫有m行n列（m&lt;=8500,n&lt;=8500） 之后输入一个m*n的矩阵 ’S‘ 表示 起点 ‘E’ 表示终点 output:输出从起点走到终点需要的最短步数min如果没有找到任何一个可行解，打印Sad思路： 从出发点(start_x,start_y)开始，每次都尝试向上下左右四个方向拓展，拓展出可行的一个解并将他们的坐标加入到队列中，所得到这些解所需要的步数应都是相同的（因为他们都属于同一层），并且它们的步数应该都是其父节点的步数加1。如果某个父节点无法继续拓展下去，那么可以将这个父节点弹出队列（因为我们已经不再需要使用到它来拓展），然后再从队首开始依次尝试拓展节点。不断重复上述操作，直到我们拓展出来的节点的坐标是终点的坐标，便不再需要拓展下去。此时这个节点存的步数值就是我们所需要的最短步数值。代码： #include &lt;iostream&gt;#include &lt;queue&gt;#define N 8500using namespace std;int n = 0,m = 0;int book[N+1][N+1];char map[N+1][N+1];queue&lt;int&gt;x;queue&lt;int&gt;y;queue&lt;int&gt;sum;int main()&#123; int next[5][2]=&#123;&#123;0,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; bool flag = false; int start_x,start_y; int finish_x,finish_y; cin&gt;&gt;m&gt;&gt;n; //输入m行,n列 for(int i = 1;i&lt;=m;i++)&#123; for(int j = 1;j&lt;=n;j++)&#123; cin&gt;&gt;map[i][j]; //读入地图 if(map[i][j] == &#x27;S&#x27;)&#123; start_x=i; start_y=j; //记录起始点的（x,y）坐标 map[i][j]=&#x27;0&#x27;; &#125; else if(map[i][j] == &#x27;E&#x27;)&#123; finish_x=i;//记录终点的（x,y）坐标 finish_y=j; map[i][j]=&#x27;0&#x27;; &#125; &#125; &#125; book[start_x][start_y]=1;//将起始点标记为已经走过 //r[tail].x=start_x; //r[tail].y=start_y;//将起始点的坐标插入队列中 //tail++; x.push(start_x); y.push(start_y); sum.push(0); while(!x.empty())&#123; //队列不为空 for(int i = 1;i&lt;=4;i++)&#123; int next_x = x.front() + next[i][0]; int next_y = y.front() + next[i][1]; //计算下一个可能被拓展的点的坐标 if(next_x &lt; 1 || next_x &gt; m || next_y &lt; 1 || next_y &gt; n) //判断是否越界 越界就重新计算可拓展点的坐标 continue; if(book[next_x][next_y] == 0 &amp;&amp; map[next_x][next_y] == &#x27;0&#x27;)&#123; //拓展点没有走过 且 可以走 x.push(next_x); y.push(next_y);//将拓展点的坐标加入到队尾 sum.push(sum.front()+1); //步数+1 book[next_x][next_y]=1;//将拓展点标记为1 表示已经走过 从其他点不会再拓展到这一点 &#125; if(next_x == finish_x &amp;&amp; next_y == finish_y)&#123; //如果拓展到了终点 flag = true; //标记变为真 表示已经到了终点 break; //不再尝试拓展其他的点 &#125; &#125; if(flag) break; //可以减少拓展次数 毕竟已经找到了终点就不需要再继续拓展下去了 x.pop(); y.pop(); sum.pop();//for循环结束以后 已经将head点可拓展的点的坐标全部加到队列中 //此时父亲点不再需要 可以将其移出队列 &#125; if(flag) cout&lt;&lt;sum.back(); else cout&lt;&lt;&quot;Sad&quot;; return 0;&#125; 3）广搜的优缺点①、BFS的时间复杂度比较小，与需要拓展的层数有关②、BFS的空间复杂度比较大，因为我们需要足够的队列空间来进行不断地入队操作tips:迷宫问题、寻找某个特定关系的人等问题可以使用广搜 END~","raw":"---\ntitle: 迷宫中的BFS和DFS问题\ndate: 2020-12-11 18:11:22\ncategories: 各种各样的算法\ntags:\n\t- C\n\t- 算法\n\t- 搜索\n---\n\n# 迷宫中的BFS和DFS问题\n\n# 前言\n\n搜索算法是一种较为常见且基础的算法\n最新在做迷宫问题的时候学习了深度优先搜索和广度优先搜索\n写一个博客来总结一下  也方便以后自己复习\n\n# 一、深度优先算法\n### 1）简介\n深度优先算法（Depth-First-Search），可以简称为DFS，是从一个点出发，通过函数的递归调用，不断地寻找下一个点。如果拓展出来的这个点已经找到了我们所需要的解，那么就开始递归返回到上一个点，如果上一个点不能再继续拓展出新的点，那么就需要递归返回到其父亲节点。不断地判断下去，最终可以得到我们的最优解。\n### 2）实例---->迷宫问题\n**Description：**\n\t小明迷路了，你可以帮他回家吗\n\t\n**Input:**\n\t第一行，输入m,n，表示该迷宫有m行n列（m<=85,n<=85）\n\t之后输入一个m*n的矩阵\n\t’S‘ 表示 起点  \n\t‘E’ 表示终点\n\t\n**output:**\n输出从起点走到终点需要的最短步数min\n如果没有找到任何一个可行解，打印Sad\n<br>\n**思路:** 从起始点开始扩展可能的点，每拓展出来一个点，在标记数组Book中将其置真值表示已经走过，在递归返回的时候不要忘记将这个点置假，因为其他的点可能会拓展到这个点上来。\n\n**代码**\n```cpp\n#include <iostream>\n#define N 90\nusing namespace std;\nchar map[N+1][N+1];\nint book[N+1][N+1];  //标记地图中每个点的状态\nint final_x,final_y; \nint _min=99999999;  //记录最后的最小步数\nint m=0,n=0;\nint next[5][2]={{0,0},{0,1},{1,0},{0,-1},{-1,0}};//方向数组\nvoid dfs(int x,int y,int sum){\n\t//如果已经到达回家的路\n\tint xr,yr;\n\tif(x == final_x && y == final_y){\n\t\tif(sum < _min) _min = sum;//如果这条路线的\n\t\t\t\t\t\t\t\t //最小步数小于当前记录的最小步数  \n\t\t\t\t\t\t\t\t //就更新\n\t\treturn;\n\t}\n\t\tfor(int i = 1;i<=4;i++){\n\t\t\txr=x+next[i][0];\n\t\t\tyr=y+next[i][1];\n\t\t\tif(xr < 1 || xr > m || yr < 1 || yr > n)   \n\t\t\t\tcontinue;\n\t\t\tif(book[xr][yr] == 0 && map[xr][yr] == '0'){\n\t\t\t\t\t\tbook[xr][yr]=1;\n\t\t\t\t\t\tdfs(xr,yr,sum+1);\n\t\t\t\t\t\tbook[xr][yr]=0; //另一条路可能会经过(xr,yr)\n\t\t\t\t\t\t\t\t     //这个点，所以需要将(xr,yr)这个点置0 \n\t\t\t\t\t}\n\t\t\t\t}\n\t\treturn;\n}\nint main(){\n\tint beginx,beginy;\n\tint sum=0;\n\tcin>>m>>n;\n\tfor(int i = 1;i<=m;i++)\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j] == 'S'){\n\t\t\t\tbeginx=i;\n\t\t\t\tbeginy=j;\n\t\t\t\tmap[i][j] = '0';\n\t\t\t}\n\t\t\telse if(map[i][j] == 'E'){\n\t\t\t\tfinal_x=i;\n\t\t\t\tfinal_y=j;\n\t\t\t\tmap[i][j] = '0';\n\t\t\t}\n\t\t}\n\tbook[beginx][beginy]=1; \n\tdfs(beginx,beginy,sum);\n\tif(_min == 99999999) cout<<\"Sad\";  //如果没有可行解  打印Sad\n\telse cout<<_min; \n\t//cout<<_min;\n\t return 0;\n\n}\n```\n\n### 3）深搜的缺点\n①、当数据量太大时，深搜的递归层数太深，容易爆栈。\n②、深搜的空间复杂度很小，但时间复杂度很高。\n\n**<b>tips:深搜一般用于棋盘问题</b>\n<br>\n\n**END~**\n<br>\n\n\n# 二、广度优先搜索\n### 1）简介\n广度优先搜索，一般称为宽度优先搜索(Breadth First Search),简称BFS。是一种层层拓展的搜索算法。每一次都向下拓展一级，从而完成对整个图(或关系)的遍历。比如：你需要寻找某一个人，这时候就先需要向你的朋友询问，那么你的朋友就属于一级关系，而如果你的朋友中无法找到这个人。那么就需要从朋友的朋友中寻找，朋友的朋友即为二级关系，一层层拓展，直到找到需要找到的人。\n### 2）实例---->迷宫问题\n**Description：**\n\t小明迷路了，你可以帮他回家吗\n\t\n**Input:**\n\t第一行，输入m,n，表示该迷宫有m行n列（m<=8500,n<=8500）\n\t之后输入一个m*n的矩阵\n\t’S‘ 表示 起点  \n\t‘E’ 表示终点\n\t\n**output:**\n输出从起点走到终点需要的最短步数min\n如果没有找到任何一个可行解，打印Sad\n<br>\n**思路：** 从出发点(start_x,start_y)开始，每次都尝试向上下左右四个方向拓展，拓展出可行的一个解并将他们的坐标加入到队列中，所得到这些解所需要的步数应都是相同的（因为他们都属于同一层），并且它们的步数应该都是其父节点的步数加1。如果某个父节点无法继续拓展下去，那么可以将这个父节点弹出队列（因为我们已经不再需要使用到它来拓展），然后再从队首开始依次尝试拓展节点。不断重复上述操作，直到我们拓展出来的节点的坐标是终点的坐标，便不再需要拓展下去。此时这个节点存的步数值就是我们所需要的最短步数值。\n**代码：**\n```cpp\n#include <iostream>\n#include <queue>\n#define N 8500\nusing namespace std;\nint n = 0,m = 0;\nint book[N+1][N+1];\nchar map[N+1][N+1];\nqueue<int>x;\nqueue<int>y;\nqueue<int>sum;\nint main(){\n\tint next[5][2]={{0,0},{0,1},{1,0},{0,-1},{-1,0}};\n\tbool flag = false;\n\tint start_x,start_y;\n\tint finish_x,finish_y;\n\tcin>>m>>n;   //输入m行,n列\n\tfor(int i = 1;i<=m;i++){\n\t\tfor(int j = 1;j<=n;j++){ \n\t\t\tcin>>map[i][j]; //读入地图\n\t\t\tif(map[i][j] == 'S'){\n\t\t\t\tstart_x=i;\n\t\t\t\tstart_y=j;  //记录起始点的（x,y）坐标\n\t\t\t\tmap[i][j]='0';\n\t\t\t}\n\t\t\telse if(map[i][j] == 'E'){\n\t\t\t\tfinish_x=i;//记录终点的（x,y）坐标\n\t\t\t\tfinish_y=j;\n\t\t\t\tmap[i][j]='0';\n\t\t\t}\n\t\t}\n\t}\n\tbook[start_x][start_y]=1;//将起始点标记为已经走过\n\t//r[tail].x=start_x;\n\t//r[tail].y=start_y;//将起始点的坐标插入队列中\n\t//tail++;\n\tx.push(start_x);\n\ty.push(start_y);\n\tsum.push(0);\n\twhile(!x.empty()){  //队列不为空\n\t\tfor(int i = 1;i<=4;i++){\n\t\t\tint next_x = x.front() + next[i][0];  \n\t\t\tint next_y = y.front() + next[i][1];  //计算下一个可能被拓展的点的坐标\n\t\t\tif(next_x < 1 || next_x > m || next_y < 1 || next_y > n)  //判断是否越界  越界就重新计算可拓展点的坐标\n\t\t\t\tcontinue;\n\t\t\tif(book[next_x][next_y] == 0 && map[next_x][next_y] == '0'){  //拓展点没有走过 且 可以走\n\t\t\t\tx.push(next_x);\n\t\t\t\ty.push(next_y);//将拓展点的坐标加入到队尾\n\t\t\t\t\tsum.push(sum.front()+1);   //步数+1\n\t\t\t\tbook[next_x][next_y]=1;//将拓展点标记为1  表示已经走过 从其他点不会再拓展到这一点\n\t\t\t}\n\t\t\tif(next_x == finish_x && next_y == finish_y){ //如果拓展到了终点\n\t\t\t\tflag = true;  //标记变为真  表示已经到了终点\n\t\t\t\tbreak;        //不再尝试拓展其他的点\n\t\t\t}\n\t\t}\t\n\t\tif(flag)  \n\t\t\tbreak;  //可以减少拓展次数 毕竟已经找到了终点就不需要再继续拓展下去了\n\t\tx.pop();\n\t\ty.pop();\n\t\tsum.pop();//for循环结束以后 已经将head点可拓展的点的坐标全部加到队列中\n\t\t\t\t//此时父亲点不再需要 可以将其移出队列\n\t}\n\tif(flag)\n\t\tcout<<sum.back();\n\telse cout<<\"Sad\";\n\treturn 0;\n}\n```\n### 3）广搜的优缺点\n①、BFS的时间复杂度比较小，与需要拓展的层数有关\n②、BFS的空间复杂度比较大，因为我们需要足够的队列空间来进行不断地入队操作\n<br>\n**tips:迷宫问题、寻找某个特定关系的人等问题可以使用广搜**\n<br><br>\n\n**END~** ","content":"<h1 id=\"迷宫中的BFS和DFS问题\"><a href=\"#迷宫中的BFS和DFS问题\" class=\"headerlink\" title=\"迷宫中的BFS和DFS问题\"></a>迷宫中的BFS和DFS问题</h1><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>搜索算法是一种较为常见且基础的算法<br>最新在做迷宫问题的时候学习了深度优先搜索和广度优先搜索<br>写一个博客来总结一下  也方便以后自己复习</p>\n<h1 id=\"一、深度优先算法\"><a href=\"#一、深度优先算法\" class=\"headerlink\" title=\"一、深度优先算法\"></a>一、深度优先算法</h1><h3 id=\"1）简介\"><a href=\"#1）简介\" class=\"headerlink\" title=\"1）简介\"></a>1）简介</h3><p>深度优先算法（Depth-First-Search），可以简称为DFS，是从一个点出发，通过函数的递归调用，不断地寻找下一个点。如果拓展出来的这个点已经找到了我们所需要的解，那么就开始递归返回到上一个点，如果上一个点不能再继续拓展出新的点，那么就需要递归返回到其父亲节点。不断地判断下去，最终可以得到我们的最优解。</p>\n<h3 id=\"2）实例—-gt-迷宫问题\"><a href=\"#2）实例—-gt-迷宫问题\" class=\"headerlink\" title=\"2）实例—-&gt;迷宫问题\"></a>2）实例—-&gt;迷宫问题</h3><p><strong>Description：</strong><br>    小明迷路了，你可以帮他回家吗</p>\n<p><strong>Input:</strong><br>    第一行，输入m,n，表示该迷宫有m行n列（m&lt;=85,n&lt;=85）<br>    之后输入一个m*n的矩阵<br>    ’S‘ 表示 起点<br>    ‘E’ 表示终点</p>\n<p><strong>output:</strong><br>输出从起点走到终点需要的最短步数min<br>如果没有找到任何一个可行解，打印Sad<br><br><br><strong>思路:</strong> 从起始点开始扩展可能的点，每拓展出来一个点，在标记数组Book中将其置真值表示已经走过，在递归返回的时候不要忘记将这个点置假，因为其他的点可能会拓展到这个点上来。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> N 90</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><span class=\"hljs-keyword\">char</span> <span class=\"hljs-built_in\">map</span>[N+<span class=\"hljs-number\">1</span>][N+<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-keyword\">int</span> book[N+<span class=\"hljs-number\">1</span>][N+<span class=\"hljs-number\">1</span>];  <span class=\"hljs-comment\">//标记地图中每个点的状态</span><br><span class=\"hljs-keyword\">int</span> final_x,final_y; <br><span class=\"hljs-keyword\">int</span> _min=<span class=\"hljs-number\">99999999</span>;  <span class=\"hljs-comment\">//记录最后的最小步数</span><br><span class=\"hljs-keyword\">int</span> m=<span class=\"hljs-number\">0</span>,n=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> next[<span class=\"hljs-number\">5</span>][<span class=\"hljs-number\">2</span>]=&#123;&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>&#125;,&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>&#125;,&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>&#125;,&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>&#125;,&#123;<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>&#125;&#125;;<span class=\"hljs-comment\">//方向数组</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x,<span class=\"hljs-keyword\">int</span> y,<span class=\"hljs-keyword\">int</span> sum)</span></span>&#123;<br>\t<span class=\"hljs-comment\">//如果已经到达回家的路</span><br>\t<span class=\"hljs-keyword\">int</span> xr,yr;<br>\t<span class=\"hljs-keyword\">if</span>(x == final_x &amp;&amp; y == final_y)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(sum &lt; _min) _min = sum;<span class=\"hljs-comment\">//如果这条路线的</span><br>\t\t\t\t\t\t\t\t <span class=\"hljs-comment\">//最小步数小于当前记录的最小步数  </span><br>\t\t\t\t\t\t\t\t <span class=\"hljs-comment\">//就更新</span><br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;i&lt;=<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t\txr=x+next[i][<span class=\"hljs-number\">0</span>];<br>\t\t\tyr=y+next[i][<span class=\"hljs-number\">1</span>];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(xr &lt; <span class=\"hljs-number\">1</span> || xr &gt; m || yr &lt; <span class=\"hljs-number\">1</span> || yr &gt; n)   <br>\t\t\t\t<span class=\"hljs-keyword\">continue</span>;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(book[xr][yr] == <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-built_in\">map</span>[xr][yr] == <span class=\"hljs-string\">&#x27;0&#x27;</span>)&#123;<br>\t\t\t\t\t\tbook[xr][yr]=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t\t\tdfs(xr,yr,sum+<span class=\"hljs-number\">1</span>);<br>\t\t\t\t\t\tbook[xr][yr]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//另一条路可能会经过(xr,yr)</span><br>\t\t\t\t\t\t\t\t     <span class=\"hljs-comment\">//这个点，所以需要将(xr,yr)这个点置0 </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> beginx,beginy;<br>\t<span class=\"hljs-keyword\">int</span> sum=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-built_in\">cin</span>&gt;&gt;m&gt;&gt;n;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;i&lt;=m;i++)<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>;j&lt;=n;j++)&#123;<br>\t\t\t<span class=\"hljs-built_in\">cin</span>&gt;&gt;<span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-string\">&#x27;S&#x27;</span>)&#123;<br>\t\t\t\tbeginx=i;<br>\t\t\t\tbeginy=j;<br>\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j] = <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-string\">&#x27;E&#x27;</span>)&#123;<br>\t\t\t\tfinal_x=i;<br>\t\t\t\tfinal_y=j;<br>\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j] = <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\tbook[beginx][beginy]=<span class=\"hljs-number\">1</span>; <br>\tdfs(beginx,beginy,sum);<br>\t<span class=\"hljs-keyword\">if</span>(_min == <span class=\"hljs-number\">99999999</span>) <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;Sad&quot;</span>;  <span class=\"hljs-comment\">//如果没有可行解  打印Sad</span><br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">cout</span>&lt;&lt;_min; <br>\t<span class=\"hljs-comment\">//cout&lt;&lt;_min;</span><br>\t <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3）深搜的缺点\"><a href=\"#3）深搜的缺点\" class=\"headerlink\" title=\"3）深搜的缺点\"></a>3）深搜的缺点</h3><p>①、当数据量太大时，深搜的递归层数太深，容易爆栈。<br>②、深搜的空间复杂度很小，但时间复杂度很高。</p>\n<p>**<b>tips:深搜一般用于棋盘问题</b><br><br></p>\n<p><strong>END~</strong><br><br></p>\n<h1 id=\"二、广度优先搜索\"><a href=\"#二、广度优先搜索\" class=\"headerlink\" title=\"二、广度优先搜索\"></a>二、广度优先搜索</h1><h3 id=\"1）简介-1\"><a href=\"#1）简介-1\" class=\"headerlink\" title=\"1）简介\"></a>1）简介</h3><p>广度优先搜索，一般称为宽度优先搜索(Breadth First Search),简称BFS。是一种层层拓展的搜索算法。每一次都向下拓展一级，从而完成对整个图(或关系)的遍历。比如：你需要寻找某一个人，这时候就先需要向你的朋友询问，那么你的朋友就属于一级关系，而如果你的朋友中无法找到这个人。那么就需要从朋友的朋友中寻找，朋友的朋友即为二级关系，一层层拓展，直到找到需要找到的人。</p>\n<h3 id=\"2）实例—-gt-迷宫问题-1\"><a href=\"#2）实例—-gt-迷宫问题-1\" class=\"headerlink\" title=\"2）实例—-&gt;迷宫问题\"></a>2）实例—-&gt;迷宫问题</h3><p><strong>Description：</strong><br>    小明迷路了，你可以帮他回家吗</p>\n<p><strong>Input:</strong><br>    第一行，输入m,n，表示该迷宫有m行n列（m&lt;=8500,n&lt;=8500）<br>    之后输入一个m*n的矩阵<br>    ’S‘ 表示 起点<br>    ‘E’ 表示终点</p>\n<p><strong>output:</strong><br>输出从起点走到终点需要的最短步数min<br>如果没有找到任何一个可行解，打印Sad<br><br><br><strong>思路：</strong> 从出发点(start_x,start_y)开始，每次都尝试向上下左右四个方向拓展，拓展出可行的一个解并将他们的坐标加入到队列中，所得到这些解所需要的步数应都是相同的（因为他们都属于同一层），并且它们的步数应该都是其父节点的步数加1。如果某个父节点无法继续拓展下去，那么可以将这个父节点弹出队列（因为我们已经不再需要使用到它来拓展），然后再从队首开始依次尝试拓展节点。不断重复上述操作，直到我们拓展出来的节点的坐标是终点的坐标，便不再需要拓展下去。此时这个节点存的步数值就是我们所需要的最短步数值。<br><strong>代码：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> N 8500</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>,m = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> book[N+<span class=\"hljs-number\">1</span>][N+<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-keyword\">char</span> <span class=\"hljs-built_in\">map</span>[N+<span class=\"hljs-number\">1</span>][N+<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-built_in\">queue</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;x;<br><span class=\"hljs-built_in\">queue</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;y;<br><span class=\"hljs-built_in\">queue</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;sum;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> next[<span class=\"hljs-number\">5</span>][<span class=\"hljs-number\">2</span>]=&#123;&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>&#125;,&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>&#125;,&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>&#125;,&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-1</span>&#125;,&#123;<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>&#125;&#125;;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">int</span> start_x,start_y;<br>\t<span class=\"hljs-keyword\">int</span> finish_x,finish_y;<br>\t<span class=\"hljs-built_in\">cin</span>&gt;&gt;m&gt;&gt;n;   <span class=\"hljs-comment\">//输入m行,n列</span><br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;i&lt;=m;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>;j&lt;=n;j++)&#123; <br>\t\t\t<span class=\"hljs-built_in\">cin</span>&gt;&gt;<span class=\"hljs-built_in\">map</span>[i][j]; <span class=\"hljs-comment\">//读入地图</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-string\">&#x27;S&#x27;</span>)&#123;<br>\t\t\t\tstart_x=i;<br>\t\t\t\tstart_y=j;  <span class=\"hljs-comment\">//记录起始点的（x,y）坐标</span><br>\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=<span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-string\">&#x27;E&#x27;</span>)&#123;<br>\t\t\t\tfinish_x=i;<span class=\"hljs-comment\">//记录终点的（x,y）坐标</span><br>\t\t\t\tfinish_y=j;<br>\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=<span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\tbook[start_x][start_y]=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//将起始点标记为已经走过</span><br>\t<span class=\"hljs-comment\">//r[tail].x=start_x;</span><br>\t<span class=\"hljs-comment\">//r[tail].y=start_y;//将起始点的坐标插入队列中</span><br>\t<span class=\"hljs-comment\">//tail++;</span><br>\tx.push(start_x);<br>\ty.push(start_y);<br>\tsum.push(<span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-keyword\">while</span>(!x.empty())&#123;  <span class=\"hljs-comment\">//队列不为空</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;i&lt;=<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> next_x = x.front() + next[i][<span class=\"hljs-number\">0</span>];  <br>\t\t\t<span class=\"hljs-keyword\">int</span> next_y = y.front() + next[i][<span class=\"hljs-number\">1</span>];  <span class=\"hljs-comment\">//计算下一个可能被拓展的点的坐标</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(next_x &lt; <span class=\"hljs-number\">1</span> || next_x &gt; m || next_y &lt; <span class=\"hljs-number\">1</span> || next_y &gt; n)  <span class=\"hljs-comment\">//判断是否越界  越界就重新计算可拓展点的坐标</span><br>\t\t\t\t<span class=\"hljs-keyword\">continue</span>;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(book[next_x][next_y] == <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-built_in\">map</span>[next_x][next_y] == <span class=\"hljs-string\">&#x27;0&#x27;</span>)&#123;  <span class=\"hljs-comment\">//拓展点没有走过 且 可以走</span><br>\t\t\t\tx.push(next_x);<br>\t\t\t\ty.push(next_y);<span class=\"hljs-comment\">//将拓展点的坐标加入到队尾</span><br>\t\t\t\t\tsum.push(sum.front()+<span class=\"hljs-number\">1</span>);   <span class=\"hljs-comment\">//步数+1</span><br>\t\t\t\tbook[next_x][next_y]=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//将拓展点标记为1  表示已经走过 从其他点不会再拓展到这一点</span><br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(next_x == finish_x &amp;&amp; next_y == finish_y)&#123; <span class=\"hljs-comment\">//如果拓展到了终点</span><br>\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;  <span class=\"hljs-comment\">//标记变为真  表示已经到了终点</span><br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;        <span class=\"hljs-comment\">//不再尝试拓展其他的点</span><br>\t\t\t&#125;<br>\t\t&#125;\t<br>\t\t<span class=\"hljs-keyword\">if</span>(flag)  <br>\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//可以减少拓展次数 毕竟已经找到了终点就不需要再继续拓展下去了</span><br>\t\tx.pop();<br>\t\ty.pop();<br>\t\tsum.pop();<span class=\"hljs-comment\">//for循环结束以后 已经将head点可拓展的点的坐标全部加到队列中</span><br>\t\t\t\t<span class=\"hljs-comment\">//此时父亲点不再需要 可以将其移出队列</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag)<br>\t\t<span class=\"hljs-built_in\">cout</span>&lt;&lt;sum.back();<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">&quot;Sad&quot;</span>;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3）广搜的优缺点\"><a href=\"#3）广搜的优缺点\" class=\"headerlink\" title=\"3）广搜的优缺点\"></a>3）广搜的优缺点</h3><p>①、BFS的时间复杂度比较小，与需要拓展的层数有关<br>②、BFS的空间复杂度比较大，因为我们需要足够的队列空间来进行不断地入队操作<br><br><br><strong>tips:迷宫问题、寻找某个特定关系的人等问题可以使用广搜</strong><br><br><br></p>\n<p><strong>END~</strong> </p>\n","slug":"sousuo","updated":"2020-12-11T10:17:50.642Z","comments":true,"link":"","permalink":"http://example.com/2020/12/11/sousuo/","excerpt":"","categories":[{"name":"各种各样的算法","slug":"各种各样的算法","permalink":"http://example.com/categories/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"搜索","permalink":"http://example.com/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"启明星工作室秋季结业作品:2048小游戏","date":"2020-12-11T05:12:50.000Z","path":"2020/12/11/SmallGame/","text":"一、小游戏简介1、起源&emsp;&emsp;2048小游戏最早于2014年3月20日发行。原版的2048最早于GitHub上发行，后被移植到了各个平台。是基于《1024》开发的新型数字游戏 2、玩法&emsp;&emsp;这款游戏的玩法很简单，每次可以选择上下左右滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢，系统也会在空白的地方乱数出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。不断的叠加最终拼凑出2048这个数字就算成功。 二、编程思路 三、各个功能的实现1、图片的制作每个正方形数字图片的大小都为60 * 60像素最后游戏窗体的大小为240 * 300像素、 2、创建2048.h头文件&emsp;&emsp;由于是使用分文件编写的方式(主要是所有函数都写在一个文件里面实在是不方便看)，所以需要创建一个头文件来声明我们需要使用到的库、变量和自定义函数，代码如下： #ifndef SMALLGAME#define SMALLGAME#include &lt;cstdio&gt;#include &lt;conio.h&gt;#include &lt;cstdlib&gt;#include &lt;graphics.h&gt; //用到的第一个非C++自带库---&gt;Easyz的图片库#include &lt;ctime&gt;//由于分文件编写的//所以注意我们定义的变量都要使用extern类型extern IMAGE img[15];//存放的是我们的15张图片extern int map[4][4];//4*4的地图extern int Imagine_number[12];void Loadimage();//加载所有的图片void DrawMap();//根据二维数组中的数据来贴上相应的图片void KeyDown();//模拟按键int RandNum();//在地图中随机产生数据int MoveRight();//向右走int MoveLeft();//向左走int MoveUp();//向上走int MoveDown();//向下走void GAMEOVER();//游戏结束void PLAYERWIN();//游戏获胜int ScanMap2();//扫描判断是否获胜bool ScanMap();//扫描判断是否游戏结束#endif 3、加载图片资源Easyx开发的图片库可以进行图片的操作，在使用图片之前，需要加载要使用的图片，一共需要加载15张图，所以直接编写一个加载图片的函数利用循环加载即可，代码如下： #include &quot;2048.h&quot;#define _CRT_SECURE_NO_WARNINGS //去除内扩增的影响void Loadimage()&#123; //加载所有的图片 for (int i = 0; i &lt; 12; i++) &#123; char FileName[200]=&#123;&#125;; sprintf(FileName,&quot;%d.jpg&quot;,Imagine_number[i]); loadimage(img + i,FileName); &#125; loadimage(img + 12, &quot;111.jpg&quot;); loadimage(img + 13, &quot;12345.jpg&quot;); loadimage(img + 14, &quot;444.jpg&quot;);&#125; 注意：sprintf具有不安全性，如果将一个长度大于原定字符数组大小的字符串存放进字符数组，就会发生越界的现象。可以使用snprintf替换sprintf 4、绘制地图遍历二维数组中的数据，根据二维数组中每个元素的数据来判断应该在某个位置贴上对应的图片，注意需要根据图片的尺寸来计算每个点的x,y坐标。代码如下： #include &quot;2048.h&quot;void DrawMap()&#123;//画地图 setbkcolor(RGB(244,215,215)); //设置窗体背景颜色 cleardevice();//更新一遍窗体 settextcolor(WHITE);//设置文本颜色 settextstyle(30,0,&quot;圆体&quot;);//字体大小 outtextxy(50,10,&quot;2048小游戏&quot;);//文字内容 int x,y,k; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; x=60*j;//列 y=60*i+60;//行 //printf(&quot;%d %d\\n&quot;,x,y); for(k = 0;k &lt; 12;k++)&#123;//遍历12张图片 if(Imagine_number[k] == map[i][j]) //判断应该贴哪一张图片 break;//退出循环 &#125; putimage(x,y,img+k);//在(x,y)的位置贴上第k张图 &#125; &#125;&#125; 5、在二维数组中产生随机数C++中产生随机数需要使用到随机数函数srand();(包含于cstdlib库中)用法：srand((unsigned int)随机数种子(NULL))若随机数种子保持不变，那么所生成的随机数也不会改变（感觉没说清楚，只能自行理解了）。故此我们一般使用电脑的系统时间作为随机数种子，也就是: srand((unsigned int)time(NULL)); 由于这里使用到了系统时间，所以需要包含C++的系统库—-&gt;ctime 在2048小游戏中，每次产生的随机数为2或4。那么如何产生这种随机数？可以这么做👇 temp=(rand()%3) * 2;注意:rand() % n得到的就是[0,n)的数据 &emsp;&emsp;那么不可避免地会生成0这么一个随机数，但我们只需要在生成后判断一次即可，如果是0，那么我们就在其他的区域内继续生成一个随机数。代码如下： #include &quot;2048.h&quot;int RandNum()&#123;//在地图中随机产生数字 srand((unsigned int)time(NULL)); for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; if(map[i][j] == 0)&#123; map[i][j] = (rand()%3)*2; if(map[i][j] == 0) continue; //如果产生的随机数为0 那么就在其他的区域内继续产生随机数 return 0; &#125; &#125; &#125; return 0;&#125; 6、按键操作Ⅰ、数的合并操作&emsp;&emsp;在上下左右的移动过程中，如果移动路径上有可以合并的数，按照规则我们需要进行合并操作； Ⅱ、数的移动&emsp;&emsp;在移动的过程中，如果某个方块在移动路径上没有数字方块，那么我们就需要对该方块进行移动操作； 不同方向上的合并和移动操作的代码是有些许不同的，但是其思想都是一样的下面就以按下右键向右移动为例: #include &quot;2048.h&quot; int MoveRight()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //判断是否可以合并 for(int j = 3;j &gt;= 0;j--)&#123; int k = j - 1;//取当前元素的前一个元素 int NowKey = map[i][j];//取当前的元素 if(NowKey != 0)&#123; // 等于0的时候再去判断是没有意义的 while(k &gt;= 0)&#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; break; //按照规则，每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 3;j&gt;=0;j--)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j - 1; while(k &gt;= 0)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125; &emsp;&emsp;其他三个方向的操作与向右移动类似，不再赘述；此时二维数组中的数据已经发生了更新；（其实如果你不想用图形库的话，可以简单的通过不断的打印二维数组实现类似的效果）更新以后，我们再根据新的数据在对应的位置来贴上对应的图片（可以理解为又覆盖上了一层图片）也就达到了移动的效果。 7、胜局判断 &emsp;&emsp;每次按键+打印地图之后对二维数组进行扫描，一旦发现了2048这个数据，那么直接跳到PLAYERWIN()这个函数。 while (1) &#123; int WINNERCHECK; KeyDown();//按下按键 DrawMap();//打印一遍地图 WINNERCHECK = ScanMap2(); if (WINNERCHECK == 1) &#123; putimage(0, 0, img + 13);//贴上游戏获胜的图片 break; &#125;//游戏获胜&#125; 8、败局判断 &emsp;&emsp;扫描地图，对四个方向尝试移动（只是尝试！没有更新二维数数组中的数据！可以想想该怎么做！），如果有一个方向还可以移动，那么就未达到败局。如果四个方向都已经尝试过且无法移动，那么就已是败局，贴上游戏失败的图片 四、整体代码&emsp;1、头文件 #ifndef SMALLGAME#define SMALLGAME#include &lt;cstdio&gt;#include &lt;conio.h&gt;#include &lt;cstdlib&gt;#include &lt;graphics.h&gt;#include &lt;ctime&gt;extern IMAGE img[15];extern int map[4][4];extern int Imagine_number[12];void Loadimage();//加载所有的图片void DrawMap();//根据二维数组中的数据来贴上相应的图片void KeyDown();//模拟按键int RandNum();//在地图中随机产生数据int MoveRight();//向右走int MoveLeft();//向左走int MoveUp();//向上走int MoveDown();//向下走void GAMEOVER();void PLAYERWIN();int ScanMap1();int ScanMap2();bool ScanMap();#endif &emsp;2、源文件 #include &quot;2048.h&quot;int Imagine_number[12]=&#123;0,2,4,8,16,32,64,128,256,512,1024,2048&#125;;int map[4][4]=&#123;0&#125;;//地图默认全部为0IMAGE img[15];/*****************************************************//*****************************************************///主函数int main()&#123; initgraph(240,300); //创建游戏窗体 Loadimage();//加载图片资源 DrawMap();//打印一遍默认的地图 while(1)&#123; int WINNERCHECK; KeyDown();//按下按键 DrawMap();//打印一遍地图 if (ScanMap() == false) &#123; getchar(); GAMEOVER(); system(&quot;cls&quot;); //putimage(0, 0, img+14); getchar(); break; &#125; WINNERCHECK= ScanMap2(); if (WINNERCHECK== 1) &#123; putimage(0, 0, img + 13); break; &#125;//游戏获胜 &#125; //getchar();//暂停窗体 //closegraph();//关闭窗体 system(&quot;pause&quot;); return 0;&#125;/*****************************************************//*****************************************************///画地图void DrawMap()&#123;//画地图 setbkcolor(RGB(244,215,215)); //设置窗体背景颜色 cleardevice();//更新一遍窗体 settextcolor(WHITE);//设置文本数据 settextstyle(30,0,&quot;楷体&quot;); outtextxy(50,10,&quot;2048小游戏&quot;); int x,y,k; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; x=60*j;//列 y=60*i+60;//行 //printf(&quot;%d %d\\n&quot;,x,y); for(k = 0;k &lt; 12;k++)&#123;//遍历12张图片 if(Imagine_number[k] == map[i][j])//如果图片的标号等于地图中的数据 break;//退出循环 &#125; putimage(x,y,img+k);//在x,y的位置贴上第k章图 &#125; &#125;&#125;/*****************************************************//*****************************************************///游戏结束void GAMEOVER() &#123; closegraph(); initgraph(240, 300); //创建游戏窗体 putimage(0, 0, img + 12); getchar();&#125; /*****************************************************//*****************************************************///模拟按键void KeyDown()&#123; char Key = _getch();//_getch()可以从键盘接受一个字符且不需要按enter键就可以执行 switch(Key) &#123; case &#x27;w&#x27;: case &#x27;W&#x27;: case 72: RandNum();//每次移动都会伴随着移动 MoveUp(); break; case &#x27;s&#x27;: case &#x27;S&#x27;: case 80: RandNum(); MoveDown(); break; case &#x27;a&#x27;: case &#x27;A&#x27;: case 75: RandNum(); MoveLeft(); break; case &#x27;d&#x27;: case &#x27;D&#x27;: case 77: RandNum(); MoveRight(); break; &#125;&#125;/*****************************************************//*****************************************************///加载图片#define _CRT_SECURE_NO_WARNINGS //去掉sprintf内扩增的影响void Loadimage()&#123; //加载所有的图片 loadimage(img + 12, &quot;111.jpg&quot;); loadimage(img + 13, &quot;12345.jpg&quot;); loadimage(img + 14, &quot;444.jpg&quot;); for (int i = 0; i &lt; 12; i++) &#123; char FileName[200]=&#123;&#125;; sprintf(FileName,&quot;%d.jpg&quot;,Imagine_number[i]); loadimage(img + i,FileName); &#125;&#125;/*****************************************************//*****************************************************///移动//不同方向的移动int MoveRight()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //判断是否可以合并 for(int j = 3;j &gt;= 0;j--)&#123; int k = j - 1; int NowKey = map[i][j];//取当前的元素 if(NowKey != 0)&#123; // 等于0的时候再去判断是没有意义的 while(k &gt;= 0)&#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 3;j&gt;=0;j--)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j - 1; while(k &gt;= 0)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125;int MoveLeft()&#123; //向左走 bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(NowKey != 0)&#123; int k = j + 1; while(k &lt; 4)&#123; //不可以越界 int NextKey = map[i][k]; if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[i][k] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j]; if(map[i][j] == 0)&#123; int k = j + 1; while(k &lt; 4)&#123; int nowkeynext = map[i][k]; if(map[i][k] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[i][k]=0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag) return 0; else return 4;&#125;int MoveUp()&#123; bool flag = false; for(int i = 0;i &lt; 4;i++)&#123; //i是行 j是列 for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(map[i][j] != 0)&#123; int k = i + 1; while(k &lt; 4)&#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[k][j] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for(int i = 0;i&lt;4;i++)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j];//取当前元素 if(map[i][j] == 0)&#123; int k = i+1; while(k &lt; 4)&#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if(map[k][j] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[k][j]=0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if(flag) return 0; else return 4;&#125;int MoveDown()&#123; bool flag = false; for(int i = 3;i &gt;= 0;i--)&#123; //i是行 j是列 for(int j = 0;j &lt; 4;j++)&#123; //遍历整个地图 int NowKey = map[i][j]; if(NowKey != 0)&#123; int k = i - 1;// while(k &gt;= 0)&#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if(NextKey != 0)&#123; //如果下一个块已经有数据 if(NextKey == NowKey)&#123; //如果下一块和当前块的数据是相同的 flag = true; map[i][j]*=2;//那么就进行合并 map[k][j] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for(int i = 3;i&gt;=0;i--)&#123; for(int j = 0;j&lt;4;j++)&#123; int nowkey = map[i][j];//取当前元素 if(map[i][j] == 0)&#123; int k = i-1; while(k &gt;= 0)&#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if(map[k][j] != 0)&#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; map[i][j]=nowkeynext; map[k][j]=0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if(flag) return 0; else return 4;&#125;/*****************************************************//*****************************************************///生成随机数int RandNum()&#123;//在地图中随机产生数字 srand((unsigned int)time(NULL)); for(int i = 0;i &lt; 4;i++)&#123; for(int j = 0;j &lt; 4;j++)&#123; if(map[i][j] == 0)&#123; map[i][j] = (rand()%3)*2; if(map[i][j] == 0) continue; //如果产生的随机数为0 那么就在其他的区域内继续产生随机数 return 0; &#125; &#125; &#125; return 0;&#125;/*****************************************************//*****************************************************///败局判断bool ScanMap() &#123; bool flag = false; /*向右走*/ for (int i = 0; i &lt; 4; i++) &#123; //判断是否可以合并 for (int j = 3; j &gt;= 0; j--) &#123; int k = j - 1; int NowKey = map[i][j];//取当前的元素 if (NowKey != 0) &#123; // 等于0的时候再去判断是没有意义的 while (k &gt;= 0) &#123; //列指针移动 int NextKey = map[i][k];//取当前元素的下一个元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[i][k] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 3; j &gt;= 0; j--) &#123; int nowkey = map[i][j]; if (map[i][j] == 0) &#123; int k = j - 1; while (k &gt;= 0) &#123; int nowkeynext = map[i][k]; if (map[i][k] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[i][k] = 0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向左走*/ for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (NowKey != 0) &#123; int k = j + 1; while (k &lt; 4) &#123; //不可以越界 int NextKey = map[i][k]; if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; ///map[i][j] *= 2;//那么就进行合并 //map[i][k] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j]; if (map[i][j] == 0) &#123; int k = j + 1; while (k &lt; 4) &#123; int nowkeynext = map[i][k]; if (map[i][k] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[i][k] = 0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向上走*/ for (int i = 0; i &lt; 4; i++) &#123; //i是行 j是列 for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (map[i][j] != 0) &#123; int k = i + 1; while (k &lt; 4) &#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[k][j] = 0; &#125; //k=4; break; //每次只能合并两个方块 &#125; k++; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j];//取当前元素 if (map[i][j] == 0) &#123; int k = i + 1; while (k &lt; 4) &#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if (map[k][j] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[k][j] = 0; //非0元素移动之后重新置为0 break; &#125; k++;//继续去判断其他的位置 &#125; &#125; &#125; &#125; /*向下走*/ for (int i = 3; i &gt;= 0; i--) &#123; //i是行 j是列 for (int j = 0; j &lt; 4; j++) &#123; //遍历整个地图 int NowKey = map[i][j]; if (NowKey != 0) &#123; int k = i - 1;// while (k &gt;= 0) &#123; //不可以越界 int NextKey = map[k][j];//取相同列的下一行元素 if (NextKey != 0) &#123; //如果下一个块已经有数据 if (NextKey == NowKey) &#123; //如果下一块和当前块的数据是相同的 flag = true; //map[i][j] *= 2;//那么就进行合并 //map[k][j] = 0; &#125; //k=-1; break; //每次只能合并两个方块 &#125; k--; &#125; &#125; &#125; &#125; for (int i = 3; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; 4; j++) &#123; int nowkey = map[i][j];//取当前元素 if (map[i][j] == 0) &#123; int k = i - 1; while (k &gt;= 0) &#123; int nowkeynext = map[k][j];//取相同列的下一行元素 if (map[k][j] != 0) &#123; //如果下一个元素不等于0,那么就需要进行合并的操作 flag = true; //map[i][j] = nowkeynext; //map[k][j] = 0; //非0元素移动之后重新置为0 break; &#125; k--;//继续去判断其他的位置 &#125; &#125; &#125; &#125; if (flag == false) return false; else return true;&#125;/*****************************************************//*****************************************************///胜局判断int ScanMap2() &#123; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (map[i][j] == 2048) return 1; &#125; &#125; return 0;&#125;/*****************************************************/ 五、总结&emsp;&emsp;进工作室以来第一次写小游戏。这一次写小游戏的过程中收获到了不少新东西：&emsp;&emsp;&emsp;&emsp;1、Easyx的图形库的使用&emsp;&emsp;&emsp;&emsp;2、随机数的生成&emsp;&emsp;&emsp;&emsp;3、_getch()和getchar()的区别&emsp;&emsp;&emsp;&emsp;4、sprintf()的用法以及其不安全性&emsp;&emsp;学会了Easyx的图形库以后可以学习做其他的小游戏。然后感觉自己还是有很多不会的东西。图书管理系统写了一小半但是感觉没有API的话写出来也没什么意思，等以后学了Java再继续完成吧。这学期剩下的时间好好复习的同时学习一点Linux服务器的知识，看能不能做出一个属于自己的博客吧！&emsp;&emsp;冲冲冲！ 六、工程项目代码以及小游戏exe文件下载这是源代码——-&gt;源代码 这是exe文件———-&gt;exe文件","raw":"---\ntitle: 启明星工作室秋季结业作品:2048小游戏\ndate: 2020-12-11 13:12:50\ncategories: Game\ntags: \n\t- C\n---\n\n# 一、小游戏简介\n## 1、起源\n&emsp;&emsp;2048小游戏最早于2014年3月20日发行。原版的2048最早于GitHub上发行，后被移植到了各个平台。是基于《1024》开发的新型数字游戏\n## 2、玩法\n&emsp;&emsp;这款游戏的玩法很简单，每次可以选择上下左右滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢，系统也会在空白的地方乱数出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。不断的叠加最终拼凑出2048这个数字就算成功。\n# 二、编程思路\n![未命名文件.jpg](https://img-blog.csdnimg.cn/img_convert/92d01392c0024d581a243e9b5145b2f4.png)\n# 三、各个功能的实现\n## 1、图片的制作\n每个正方形数字图片的大小都为60 * 60像素\n最后游戏窗体的大小为240 * 300像素、\n## 2、创建2048.h头文件\n&emsp;&emsp;由于是使用分文件编写的方式(主要是所有函数都写在一个文件里面实在是不方便看)，所以需要创建一个头文件来声明我们需要使用到的库、变量和自定义函数，代码如下：\n\n```cpp\n#ifndef SMALLGAME\n#define SMALLGAME\n#include <cstdio>\n#include <conio.h>\n#include <cstdlib>\n#include <graphics.h> //用到的第一个非C++自带库--->Easyz的图片库\n#include <ctime>\n//由于分文件编写的\n//所以注意我们定义的变量都要使用extern类型\nextern IMAGE img[15];//存放的是我们的15张图片\nextern int map[4][4];//4*4的地图\nextern int Imagine_number[12];\nvoid Loadimage();//加载所有的图片\nvoid DrawMap();//根据二维数组中的数据来贴上相应的图片\nvoid KeyDown();//模拟按键\nint RandNum();//在地图中随机产生数据\nint MoveRight();//向右走\nint MoveLeft();//向左走\nint MoveUp();//向上走\nint MoveDown();//向下走\nvoid GAMEOVER();//游戏结束\nvoid PLAYERWIN();//游戏获胜\nint ScanMap2();//扫描判断是否获胜\nbool ScanMap();//扫描判断是否游戏结束\n#endif\n```\n## 3、加载图片资源\nEasyx开发的图片库可以进行图片的操作，在使用图片之前，需要加载要使用的图片，一共需要加载15张图，所以直接编写一个加载图片的函数利用循环加载即可，代码如下：\n\n```cpp\n#include \"2048.h\"\n#define _CRT_SECURE_NO_WARNINGS //去除内扩增的影响\nvoid Loadimage(){  //加载所有的图片\n\tfor (int i = 0; i < 12; i++) {\n\t\tchar FileName[200]={};\n\t\tsprintf(FileName,\"%d.jpg\",Imagine_number[i]);\n\t\tloadimage(img + i,FileName);\n\t}\n\tloadimage(img + 12, \"111.jpg\");\n\tloadimage(img + 13, \"12345.jpg\");\n\tloadimage(img + 14, \"444.jpg\");\n}\n```\n注意：sprintf具有不安全性，如果将一个长度大于原定字符数组大小的字符串存放进字符数组，就会发生越界的现象。可以使用snprintf替换sprintf\n## 4、绘制地图\n遍历二维数组中的数据，根据二维数组中每个元素的数据来判断应该在某个位置贴上对应的图片，注意需要根据图片的尺寸来计算每个点的x,y坐标。\n代码如下：\n\n```cpp\n#include \"2048.h\"\nvoid DrawMap(){//画地图\n\tsetbkcolor(RGB(244,215,215));  //设置窗体背景颜色\n\tcleardevice();//更新一遍窗体\n\tsettextcolor(WHITE);//设置文本颜色\n\tsettextstyle(30,0,\"圆体\");//字体大小\n\touttextxy(50,10,\"2048小游戏\");//文字内容\n\tint x,y,k;\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tx=60*j;//列\n\t\t\ty=60*i+60;//行\n\t\t\t//printf(\"%d %d\\n\",x,y);\n\t\t\tfor(k = 0;k < 12;k++){//遍历12张图片\n\t\t\t\tif(Imagine_number[k] == map[i][j])\n\t\t\t\t//判断应该贴哪一张图片\n\t\t\t\t\tbreak;//退出循环\n\t\t\t}\n\t\t\tputimage(x,y,img+k);//在(x,y)的位置贴上第k张图\n\t\t}\n\t}\n}\n```\n\n## 5、在二维数组中产生随机数\nC++中产生随机数需要使用到随机数函数srand();(包含于cstdlib库中)\n用法：srand((unsigned int)随机数种子(NULL))\n若随机数种子保持不变，那么所生成的随机数也不会改变（感觉没说清楚，只能自行理解了）。故此我们一般使用电脑的系统时间作为随机数种子，也就是:\n```\nsrand((unsigned int)time(NULL));\n```\n由于这里使用到了系统时间，所以需要包含C++的系统库---->**ctime**\n\n在2048小游戏中，每次产生的随机数为2或4。\n那么如何产生这种随机数？可以这么做👇\n```\ntemp=(rand()%3) * 2;\n注意:rand() % n得到的就是[0,n)的数据\n```\n&emsp;&emsp;那么不可避免地会生成0这么一个随机数，但我们只需要在生成后判断一次即可，如果是0，那么我们就在其他的区域内继续生成一个随机数。\n代码如下：\n```cpp\n#include \"2048.h\"\nint RandNum(){//在地图中随机产生数字\n\tsrand((unsigned int)time(NULL));\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tmap[i][j] = (rand()%3)*2;\n\t\t\t\tif(map[i][j] == 0) continue;  //如果产生的随机数为0  那么就在其他的区域内继续产生随机数\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## 6、按键操作\n### Ⅰ、数的合并操作\n&emsp;&emsp;在上下左右的移动过程中，如果移动路径上有可以合并的数，按照规则我们需要进行合并操作；\n\n### Ⅱ、数的移动\n&emsp;&emsp;在移动的过程中，如果某个方块在移动路径上没有数字方块，那么我们就需要对该方块进行移动操作；\n ```\n 不同方向上的合并和移动操作的代码是有些许不同的，但是其思想都是一样的\n 下面就以按下右键向右移动为例:\n ```\n ```cpp\n #include \"2048.h\"\n int MoveRight(){\n\tbool flag = false;\n\tfor(int i = 0;i < 4;i++){  //判断是否可以合并\n\t\tfor(int j = 3;j >= 0;j--){  \n\t\t\tint k = j - 1;//取当前元素的前一个元素\n\t\t\tint NowKey = map[i][j];//取当前的元素\n\t\t\tif(NowKey != 0){ // 等于0的时候再去判断是没有意义的\n\t\t\t\twhile(k >= 0){  //列指针移动\n\t\t\t\t\tint NextKey = map[i][k];//取当前元素的下一个元素\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;  //按照规则，每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i<4;i++){\n\t\tfor(int j = 3;j>=0;j--){\n\t\t\tint nowkey = map[i][j];\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = j - 1;\n\t\t\t\twhile(k >= 0){\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif(map[i][k] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[i][k]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tif (flag) return 0;\n\telse return 4;\n}\n ```\n &emsp;&emsp;其他三个方向的操作与向右移动类似，不再赘述；此时二维数组中的数据已经发生了更新；（其实如果你不想用图形库的话，可以简单的通过不断的打印二维数组实现类似的效果）更新以后，我们再根据新的数据在对应的位置来贴上对应的图片（可以理解为又覆盖上了一层图片）也就达到了移动的效果。\n ## 7、胜局判断\n &emsp;&emsp;每次按键+打印地图之后对二维数组进行扫描，一旦发现了2048这个数据，那么直接跳到PLAYERWIN()这个函数。\n ```cpp\n \twhile (1) \n \t{\n\t\t\tint WINNERCHECK;\n\t\t\tKeyDown();//按下按键\n\t\t\tDrawMap();//打印一遍地图\n\t\t\tWINNERCHECK = ScanMap2();\n\t\t\tif (WINNERCHECK == 1) \n\t\t\t{\n\t\t\t\tputimage(0, 0, img + 13);//贴上游戏获胜的图片\n\t\t\t\tbreak; \n\t\t\t}//游戏获胜\n\t}\n ```\n ## 8、败局判断\n &emsp;&emsp;扫描地图，对四个方向尝试移动（只是尝试！没有更新二维数数组中的数据！可以想想该怎么做！），如果有一个方向还可以移动，那么就未达到败局。如果四个方向都已经尝试过且无法移动，那么就已是败局，贴上游戏失败的图片\n\n # 四、整体代码\n&emsp;1、头文件\n```cpp\n#ifndef SMALLGAME\n#define SMALLGAME\n#include <cstdio>\n#include <conio.h>\n#include <cstdlib>\n#include <graphics.h>\n#include <ctime>\nextern IMAGE img[15];\nextern int map[4][4];\nextern int Imagine_number[12];\nvoid Loadimage();//加载所有的图片\nvoid DrawMap();//根据二维数组中的数据来贴上相应的图片\nvoid KeyDown();//模拟按键\nint RandNum();//在地图中随机产生数据\nint MoveRight();//向右走\nint MoveLeft();//向左走\nint MoveUp();//向上走\nint MoveDown();//向下走\nvoid GAMEOVER();\nvoid PLAYERWIN();\nint ScanMap1();\nint ScanMap2();\nbool ScanMap();\n#endif\n```\n&emsp;2、源文件\n```cpp\n#include \"2048.h\"\nint Imagine_number[12]={0,2,4,8,16,32,64,128,256,512,1024,2048};\nint map[4][4]={0};//地图默认全部为0\nIMAGE img[15];\n/*****************************************************/\n\n/*****************************************************/\n//主函数\nint main(){\n\tinitgraph(240,300);  //创建游戏窗体\n\tLoadimage();//加载图片资源\n\tDrawMap();//打印一遍默认的地图\n\twhile(1){\n\t\tint WINNERCHECK;\n\t\tKeyDown();//按下按键\n\t\tDrawMap();//打印一遍地图\n\t\tif (ScanMap() == false) {\n\t\t\tgetchar();\n\t\t\tGAMEOVER();\n\t\t\tsystem(\"cls\");\n\t\t\t//putimage(0, 0, img+14);\n\t\t\tgetchar();\n\t\t\tbreak;\n\t\t}\n\t\tWINNERCHECK= ScanMap2();\n\t\tif (WINNERCHECK== 1) { putimage(0, 0, img + 13); break; }//游戏获胜\n\t}\n\t//getchar();//暂停窗体\n\t//closegraph();//关闭窗体\n\tsystem(\"pause\");\n\treturn 0;\n}\n/*****************************************************/\n\n/*****************************************************/\n//画地图\nvoid DrawMap(){//画地图\n\tsetbkcolor(RGB(244,215,215));  //设置窗体背景颜色\n\tcleardevice();//更新一遍窗体\n\tsettextcolor(WHITE);//设置文本数据\n\tsettextstyle(30,0,\"楷体\");\n\touttextxy(50,10,\"2048小游戏\");\n\tint x,y,k;\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tx=60*j;//列\n\t\t\ty=60*i+60;//行\n\t\t\t//printf(\"%d %d\\n\",x,y);\n\t\t\tfor(k = 0;k < 12;k++){//遍历12张图片\n\t\t\t\tif(Imagine_number[k] == map[i][j])//如果图片的标号等于地图中的数据\n\t\t\t\t\tbreak;//退出循环\n\t\t\t}\n\t\t\tputimage(x,y,img+k);//在x,y的位置贴上第k章图\n\t\t}\n\t}\n}\n/*****************************************************/\n\n/*****************************************************/\n//游戏结束\nvoid GAMEOVER() {\n\tclosegraph();\n\tinitgraph(240, 300);  //创建游戏窗体\n\tputimage(0, 0, img + 12);\n\tgetchar();\n} \n/*****************************************************/\n\n/*****************************************************/\n//模拟按键\nvoid KeyDown(){\n\tchar Key = _getch();//_getch()可以从键盘接受一个字符且不需要按enter键就可以执行\n\tswitch(Key)\n\t{\n\t\tcase 'w':\n\t\tcase 'W':\n\t\tcase  72:\n\t\t\tRandNum();//每次移动都会伴随着移动\n\t\t\tMoveUp();\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\tcase  80:\n\t\t\tRandNum();\n\t\t\tMoveDown();\t\t\t\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'A': \n\t\tcase 75:\n\t\t\tRandNum();\n\t\t\tMoveLeft();\t\t\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\tcase 77:\n\t\t\tRandNum();\n\t\t\tMoveRight();\t\t\n\t\t\tbreak;\n\t}\n}\n/*****************************************************/\n\n/*****************************************************/\n//加载图片\n#define _CRT_SECURE_NO_WARNINGS //去掉sprintf内扩增的影响\nvoid Loadimage(){  //加载所有的图片\n\tloadimage(img + 12, \"111.jpg\");\n\tloadimage(img + 13, \"12345.jpg\");\n\tloadimage(img + 14, \"444.jpg\");\n\tfor (int i = 0; i < 12; i++) {\n\t\tchar FileName[200]={};\n\t\tsprintf(FileName,\"%d.jpg\",Imagine_number[i]);\n\t\tloadimage(img + i,FileName);\n\t}\n}\n/*****************************************************/\n\n/*****************************************************/\n//移动\n//不同方向的移动\nint MoveRight(){\n\tbool flag = false;\n\tfor(int i = 0;i < 4;i++){  //判断是否可以合并\n\t\tfor(int j = 3;j >= 0;j--){  \n\t\t\tint k = j - 1;\n\t\t\tint NowKey = map[i][j];//取当前的元素\n\t\t\tif(NowKey != 0){ // 等于0的时候再去判断是没有意义的\n\t\t\t\twhile(k >= 0){  //列指针移动\n\t\t\t\t\tint NextKey = map[i][k];//取当前元素的下一个元素\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=-1;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i<4;i++){\n\t\tfor(int j = 3;j>=0;j--){\n\t\t\tint nowkey = map[i][j];\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = j - 1;\n\t\t\t\twhile(k >= 0){\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif(map[i][k] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[i][k]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tif (flag) return 0;\n\telse return 4;\n}\nint MoveLeft(){  //向左走\n\tbool flag = false;\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif(NowKey != 0){\n\t\t\t\tint k = j + 1;\n\t\t\t\twhile(k < 4){  //不可以越界\n\t\t\t\t\tint NextKey = map[i][k];\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=4;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i<4;i++){\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tint nowkey = map[i][j];\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = j + 1;\n\t\t\t\twhile(k < 4){\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif(map[i][k] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[i][k]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk++;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag) return 0;\n\telse return 4;\n}\nint MoveUp(){\n\tbool flag = false;\n\tfor(int i = 0;i < 4;i++){ //i是行 j是列\n\t\tfor(int j = 0;j < 4;j++){  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif(map[i][j] != 0){\n\t\t\t\tint k = i + 1;\n\t\t\t\twhile(k < 4){  //不可以越界\n\t\t\t\t\tint NextKey = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[k][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=4;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i<4;i++){\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tint nowkey = map[i][j];//取当前元素\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = i+1;\n\t\t\t\twhile(k < 4){\n\t\t\t\t\tint nowkeynext = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif(map[k][j] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[k][j]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk++;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag) return 0;\n\telse return 4;\n}\nint MoveDown(){\n\tbool flag = false;\n\tfor(int i = 3;i >= 0;i--){ //i是行 j是列\n\t\tfor(int j = 0;j < 4;j++){  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif(NowKey != 0){\n\t\t\t\tint k = i - 1;//\n\t\t\t\twhile(k >= 0){  //不可以越界\n\t\t\t\t\tint NextKey = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif(NextKey != 0){ //如果下一个块已经有数据\n\t\t\t\t\t\tif(NextKey == NowKey){  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tmap[i][j]*=2;//那么就进行合并\n\t\t\t\t\t\t\tmap[k][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=-1;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 3;i>=0;i--){\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tint nowkey = map[i][j];//取当前元素\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tint k = i-1;\n\t\t\t\twhile(k >= 0){\n\t\t\t\t\tint nowkeynext = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif(map[k][j] != 0){  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tmap[i][j]=nowkeynext;\n\t\t\t\t\t\tmap[k][j]=0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag) return 0;\n\telse return 4;\n}\n/*****************************************************/\n\n/*****************************************************/\n//生成随机数\nint RandNum(){//在地图中随机产生数字\n\tsrand((unsigned int)time(NULL));\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tif(map[i][j] == 0){\n\t\t\t\tmap[i][j] = (rand()%3)*2;\n\t\t\t\tif(map[i][j] == 0) continue;  //如果产生的随机数为0  那么就在其他的区域内继续产生随机数\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*****************************************************/\n\n/*****************************************************/\n//败局判断\nbool ScanMap() {\n\tbool flag = false;\n\t/*向右走*/\n\tfor (int i = 0; i < 4; i++) {  //判断是否可以合并\n\t\tfor (int j = 3; j >= 0; j--) {\n\t\t\tint k = j - 1;\n\t\t\tint NowKey = map[i][j];//取当前的元素\n\t\t\tif (NowKey != 0) { // 等于0的时候再去判断是没有意义的\n\t\t\t\twhile (k >= 0) {  //列指针移动\n\t\t\t\t\tint NextKey = map[i][k];//取当前元素的下一个元素\n\t\t\t\t\tif (NextKey != 0) { //如果下一个块已经有数据\n\t\t\t\t\t\tif (NextKey == NowKey) {  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t//map[i][j] *= 2;//那么就进行合并\n\t\t\t\t\t\t\t//map[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=-1;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 3; j >= 0; j--) {\n\t\t\tint nowkey = map[i][j];\n\t\t\tif (map[i][j] == 0) {\n\t\t\t\tint k = j - 1;\n\t\t\t\twhile (k >= 0) {\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif (map[i][k] != 0) {  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t//map[i][j] = nowkeynext;\n\t\t\t\t\t\t//map[i][k] = 0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t/*向左走*/\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 4; j++) {  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif (NowKey != 0) {\n\t\t\t\tint k = j + 1;\n\t\t\t\twhile (k < 4) {  //不可以越界\n\t\t\t\t\tint NextKey = map[i][k];\n\t\t\t\t\tif (NextKey != 0) { //如果下一个块已经有数据\n\t\t\t\t\t\tif (NextKey == NowKey) {  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t///map[i][j] *= 2;//那么就进行合并\n\t\t\t\t\t\t\t//map[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=4;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint nowkey = map[i][j];\n\t\t\tif (map[i][j] == 0) {\n\t\t\t\tint k = j + 1;\n\t\t\t\twhile (k < 4) {\n\t\t\t\t\tint nowkeynext = map[i][k];\n\t\t\t\t\tif (map[i][k] != 0) {  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t//map[i][j] = nowkeynext;\n\t\t\t\t\t\t//map[i][k] = 0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk++;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*向上走*/\n\tfor (int i = 0; i < 4; i++) { //i是行 j是列\n\t\tfor (int j = 0; j < 4; j++) {  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif (map[i][j] != 0) {\n\t\t\t\tint k = i + 1;\n\t\t\t\twhile (k < 4) {  //不可以越界\n\t\t\t\t\tint NextKey = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif (NextKey != 0) { //如果下一个块已经有数据\n\t\t\t\t\t\tif (NextKey == NowKey) {  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t//map[i][j] *= 2;//那么就进行合并\n\t\t\t\t\t\t\t//map[k][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=4;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint nowkey = map[i][j];//取当前元素\n\t\t\tif (map[i][j] == 0) {\n\t\t\t\tint k = i + 1;\n\t\t\t\twhile (k < 4) {\n\t\t\t\t\tint nowkeynext = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif (map[k][j] != 0) {  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t//map[i][j] = nowkeynext;\n\t\t\t\t\t\t//map[k][j] = 0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk++;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*向下走*/\n\tfor (int i = 3; i >= 0; i--) { //i是行 j是列\n\t\tfor (int j = 0; j < 4; j++) {  //遍历整个地图\n\t\t\tint NowKey = map[i][j];\n\t\t\tif (NowKey != 0) {\n\t\t\t\tint k = i - 1;//\n\t\t\t\twhile (k >= 0) {  //不可以越界\n\t\t\t\t\tint NextKey = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif (NextKey != 0) { //如果下一个块已经有数据\n\t\t\t\t\t\tif (NextKey == NowKey) {  //如果下一块和当前块的数据是相同的\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t//map[i][j] *= 2;//那么就进行合并\n\t\t\t\t\t\t\t//map[k][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//k=-1;\n\t\t\t\t\t\tbreak;  //每次只能合并两个方块   \n\t\t\t\t\t}\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 3; i >= 0; i--) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint nowkey = map[i][j];//取当前元素\n\t\t\tif (map[i][j] == 0) {\n\t\t\t\tint k = i - 1;\n\t\t\t\twhile (k >= 0) {\n\t\t\t\t\tint nowkeynext = map[k][j];//取相同列的下一行元素\n\t\t\t\t\tif (map[k][j] != 0) {  //如果下一个元素不等于0,那么就需要进行合并的操作\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t//map[i][j] = nowkeynext;\n\t\t\t\t\t\t//map[k][j] = 0; //非0元素移动之后重新置为0\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk--;//继续去判断其他的位置\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == false) return false;\n\telse return true;\n}\n/*****************************************************/\n\n/*****************************************************/\n//胜局判断\nint ScanMap2() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (map[i][j] == 2048) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n/*****************************************************/\n```\n\n# 五、总结\n&emsp;&emsp;进工作室以来第一次写小游戏。这一次写小游戏的过程中收获到了不少新东西：\n&emsp;&emsp;&emsp;&emsp;1、**Easyx的图形库的使用**\n&emsp;&emsp;&emsp;&emsp;2、随机数的生成\n&emsp;&emsp;&emsp;&emsp;3、_getch()和getchar()的区别\n&emsp;&emsp;&emsp;&emsp;4、sprintf()的用法以及其不安全性\n&emsp;&emsp;学会了Easyx的图形库以后可以学习做其他的小游戏。然后感觉自己还是有很多不会的东西。图书管理系统写了一小半但是感觉没有API的话写出来也没什么意思，等以后学了Java再继续完成吧。这学期剩下的时间好好复习的同时学习一点Linux服务器的知识，看能不能做出一个属于自己的博客吧！\n&emsp;&emsp;冲冲冲！\n\n# 六、工程项目代码以及小游戏exe文件下载\n\n~~**这是源代码**~~------->[源代码](https://github.com/yxr2333/Smallgame/blob/master/sourcecode--vs2019.rar)\n\n**~~这是exe文件~~**---------->[exe文件](https://github.com/yxr2333/Smallgame/blob/master/Smallgame.rar)\n\n","content":"<h1 id=\"一、小游戏简介\"><a href=\"#一、小游戏简介\" class=\"headerlink\" title=\"一、小游戏简介\"></a>一、小游戏简介</h1><h2 id=\"1、起源\"><a href=\"#1、起源\" class=\"headerlink\" title=\"1、起源\"></a>1、起源</h2><p>&emsp;&emsp;2048小游戏最早于2014年3月20日发行。原版的2048最早于GitHub上发行，后被移植到了各个平台。是基于《1024》开发的新型数字游戏</p>\n<h2 id=\"2、玩法\"><a href=\"#2、玩法\" class=\"headerlink\" title=\"2、玩法\"></a>2、玩法</h2><p>&emsp;&emsp;这款游戏的玩法很简单，每次可以选择上下左右滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢，系统也会在空白的地方乱数出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。不断的叠加最终拼凑出2048这个数字就算成功。</p>\n<h1 id=\"二、编程思路\"><a href=\"#二、编程思路\" class=\"headerlink\" title=\"二、编程思路\"></a>二、编程思路</h1><p><img src=\"https://img-blog.csdnimg.cn/img_convert/92d01392c0024d581a243e9b5145b2f4.png\" alt=\"未命名文件.jpg\"></p>\n<h1 id=\"三、各个功能的实现\"><a href=\"#三、各个功能的实现\" class=\"headerlink\" title=\"三、各个功能的实现\"></a>三、各个功能的实现</h1><h2 id=\"1、图片的制作\"><a href=\"#1、图片的制作\" class=\"headerlink\" title=\"1、图片的制作\"></a>1、图片的制作</h2><p>每个正方形数字图片的大小都为60 * 60像素<br>最后游戏窗体的大小为240 * 300像素、</p>\n<h2 id=\"2、创建2048-h头文件\"><a href=\"#2、创建2048-h头文件\" class=\"headerlink\" title=\"2、创建2048.h头文件\"></a>2、创建2048.h头文件</h2><p>&emsp;&emsp;由于是使用分文件编写的方式(主要是所有函数都写在一个文件里面实在是不方便看)，所以需要创建一个头文件来声明我们需要使用到的库、变量和自定义函数，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">ifndef</span> SMALLGAME</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> SMALLGAME</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;conio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdlib&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;graphics.h&gt; //用到的第一个非C++自带库---&gt;Easyz的图片库</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;ctime&gt;</span></span><br><span class=\"hljs-comment\">//由于分文件编写的</span><br><span class=\"hljs-comment\">//所以注意我们定义的变量都要使用extern类型</span><br><span class=\"hljs-keyword\">extern</span> IMAGE img[<span class=\"hljs-number\">15</span>];<span class=\"hljs-comment\">//存放的是我们的15张图片</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">map</span>[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>];<span class=\"hljs-comment\">//4*4的地图</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">int</span> Imagine_number[<span class=\"hljs-number\">12</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Loadimage</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//加载所有的图片</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DrawMap</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//根据二维数组中的数据来贴上相应的图片</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">KeyDown</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//模拟按键</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">RandNum</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//在地图中随机产生数据</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveRight</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向右走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveLeft</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向左走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveUp</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向上走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveDown</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向下走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GAMEOVER</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//游戏结束</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PLAYERWIN</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//游戏获胜</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ScanMap2</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//扫描判断是否获胜</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ScanMap</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//扫描判断是否游戏结束</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n<h2 id=\"3、加载图片资源\"><a href=\"#3、加载图片资源\" class=\"headerlink\" title=\"3、加载图片资源\"></a>3、加载图片资源</h2><p>Easyx开发的图片库可以进行图片的操作，在使用图片之前，需要加载要使用的图片，一共需要加载15张图，所以直接编写一个加载图片的函数利用循环加载即可，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> _CRT_SECURE_NO_WARNINGS <span class=\"hljs-comment\">//去除内扩增的影响</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Loadimage</span><span class=\"hljs-params\">()</span></span>&#123;  <span class=\"hljs-comment\">//加载所有的图片</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">12</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">char</span> FileName[<span class=\"hljs-number\">200</span>]=&#123;&#125;;<br>\t\t<span class=\"hljs-built_in\">sprintf</span>(FileName,<span class=\"hljs-string\">&quot;%d.jpg&quot;</span>,Imagine_number[i]);<br>\t\tloadimage(img + i,FileName);<br>\t&#125;<br>\tloadimage(img + <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&quot;111.jpg&quot;</span>);<br>\tloadimage(img + <span class=\"hljs-number\">13</span>, <span class=\"hljs-string\">&quot;12345.jpg&quot;</span>);<br>\tloadimage(img + <span class=\"hljs-number\">14</span>, <span class=\"hljs-string\">&quot;444.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>注意：sprintf具有不安全性，如果将一个长度大于原定字符数组大小的字符串存放进字符数组，就会发生越界的现象。可以使用snprintf替换sprintf</p>\n<h2 id=\"4、绘制地图\"><a href=\"#4、绘制地图\" class=\"headerlink\" title=\"4、绘制地图\"></a>4、绘制地图</h2><p>遍历二维数组中的数据，根据二维数组中每个元素的数据来判断应该在某个位置贴上对应的图片，注意需要根据图片的尺寸来计算每个点的x,y坐标。<br>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DrawMap</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//画地图</span><br>\tsetbkcolor(RGB(<span class=\"hljs-number\">244</span>,<span class=\"hljs-number\">215</span>,<span class=\"hljs-number\">215</span>));  <span class=\"hljs-comment\">//设置窗体背景颜色</span><br>\tcleardevice();<span class=\"hljs-comment\">//更新一遍窗体</span><br>\tsettextcolor(WHITE);<span class=\"hljs-comment\">//设置文本颜色</span><br>\tsettextstyle(<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&quot;圆体&quot;</span>);<span class=\"hljs-comment\">//字体大小</span><br>\touttextxy(<span class=\"hljs-number\">50</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-string\">&quot;2048小游戏&quot;</span>);<span class=\"hljs-comment\">//文字内容</span><br>\t<span class=\"hljs-keyword\">int</span> x,y,k;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\tx=<span class=\"hljs-number\">60</span>*j;<span class=\"hljs-comment\">//列</span><br>\t\t\ty=<span class=\"hljs-number\">60</span>*i+<span class=\"hljs-number\">60</span>;<span class=\"hljs-comment\">//行</span><br>\t\t\t<span class=\"hljs-comment\">//printf(&quot;%d %d\\n&quot;,x,y);</span><br>\t\t\t<span class=\"hljs-keyword\">for</span>(k = <span class=\"hljs-number\">0</span>;k &lt; <span class=\"hljs-number\">12</span>;k++)&#123;<span class=\"hljs-comment\">//遍历12张图片</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(Imagine_number[k] == <span class=\"hljs-built_in\">map</span>[i][j])<br>\t\t\t\t<span class=\"hljs-comment\">//判断应该贴哪一张图片</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//退出循环</span><br>\t\t\t&#125;<br>\t\t\tputimage(x,y,img+k);<span class=\"hljs-comment\">//在(x,y)的位置贴上第k张图</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5、在二维数组中产生随机数\"><a href=\"#5、在二维数组中产生随机数\" class=\"headerlink\" title=\"5、在二维数组中产生随机数\"></a>5、在二维数组中产生随机数</h2><p>C++中产生随机数需要使用到随机数函数srand();(包含于cstdlib库中)<br>用法：srand((unsigned int)随机数种子(NULL))<br>若随机数种子保持不变，那么所生成的随机数也不会改变（感觉没说清楚，只能自行理解了）。故此我们一般使用电脑的系统时间作为随机数种子，也就是:</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-function\"><span class=\"hljs-title\">srand</span>((<span class=\"hljs-variable\">unsigned</span> <span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\"><span class=\"hljs-built_in\">time</span></span>(<span class=\"hljs-variable\"><span class=\"hljs-literal\">NULL</span></span>));</span><br></code></pre></td></tr></table></figure>\n<p>由于这里使用到了系统时间，所以需要包含C++的系统库—-&gt;<strong>ctime</strong></p>\n<p>在2048小游戏中，每次产生的随机数为2或4。<br>那么如何产生这种随机数？可以这么做👇</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><code class=\"hljs matlab\">temp=(<span class=\"hljs-built_in\">rand</span>()<span class=\"hljs-comment\">%3) * 2;</span><br>注意:<span class=\"hljs-built_in\">rand</span>() <span class=\"hljs-comment\">% n得到的就是[0,n)的数据</span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;那么不可避免地会生成0这么一个随机数，但我们只需要在生成后判断一次即可，如果是0，那么我们就在其他的区域内继续生成一个随机数。<br>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">RandNum</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//在地图中随机产生数字</span><br>\tsrand((<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>)time(<span class=\"hljs-literal\">NULL</span>));<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j] = (rand()%<span class=\"hljs-number\">3</span>)*<span class=\"hljs-number\">2</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">continue</span>;  <span class=\"hljs-comment\">//如果产生的随机数为0  那么就在其他的区域内继续产生随机数</span><br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6、按键操作\"><a href=\"#6、按键操作\" class=\"headerlink\" title=\"6、按键操作\"></a>6、按键操作</h2><h3 id=\"Ⅰ、数的合并操作\"><a href=\"#Ⅰ、数的合并操作\" class=\"headerlink\" title=\"Ⅰ、数的合并操作\"></a>Ⅰ、数的合并操作</h3><p>&emsp;&emsp;在上下左右的移动过程中，如果移动路径上有可以合并的数，按照规则我们需要进行合并操作；</p>\n<h3 id=\"Ⅱ、数的移动\"><a href=\"#Ⅱ、数的移动\" class=\"headerlink\" title=\"Ⅱ、数的移动\"></a>Ⅱ、数的移动</h3><p>&emsp;&emsp;在移动的过程中，如果某个方块在移动路径上没有数字方块，那么我们就需要对该方块进行移动操作；<br> <figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><code class=\"hljs makefile\">不同方向上的合并和移动操作的代码是有些许不同的，但是其思想都是一样的<br><span class=\"hljs-section\">下面就以按下右键向右移动为例:</span><br></code></pre></td></tr></table></figure><br> <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"> <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br> <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveRight</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;  <span class=\"hljs-comment\">//判断是否可以合并</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>;j &gt;= <span class=\"hljs-number\">0</span>;j--)&#123;  <br>\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//取当前元素的前一个元素</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前的元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(NowKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">// 等于0的时候再去判断是没有意义的</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//列指针移动</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<span class=\"hljs-comment\">//取当前元素的下一个元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//按照规则，每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>;j&gt;=<span class=\"hljs-number\">0</span>;j--)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t\t<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br> &emsp;&emsp;其他三个方向的操作与向右移动类似，不再赘述；此时二维数组中的数据已经发生了更新；（其实如果你不想用图形库的话，可以简单的通过不断的打印二维数组实现类似的效果）更新以后，我们再根据新的数据在对应的位置来贴上对应的图片（可以理解为又覆盖上了一层图片）也就达到了移动的效果。</p>\n<h2 id=\"7、胜局判断\"><a href=\"#7、胜局判断\" class=\"headerlink\" title=\"7、胜局判断\"></a>7、胜局判断</h2><p> &emsp;&emsp;每次按键+打印地图之后对二维数组进行扫描，一旦发现了2048这个数据，那么直接跳到PLAYERWIN()这个函数。<br> <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) <br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> WINNERCHECK;<br>\t\tKeyDown();<span class=\"hljs-comment\">//按下按键</span><br>\t\tDrawMap();<span class=\"hljs-comment\">//打印一遍地图</span><br>\t\tWINNERCHECK = ScanMap2();<br>\t\t<span class=\"hljs-keyword\">if</span> (WINNERCHECK == <span class=\"hljs-number\">1</span>) <br>\t\t&#123;<br>\t\t\tputimage(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, img + <span class=\"hljs-number\">13</span>);<span class=\"hljs-comment\">//贴上游戏获胜的图片</span><br>\t\t\t<span class=\"hljs-keyword\">break</span>; <br>\t\t&#125;<span class=\"hljs-comment\">//游戏获胜</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"8、败局判断\"><a href=\"#8、败局判断\" class=\"headerlink\" title=\"8、败局判断\"></a>8、败局判断</h2><p> &emsp;&emsp;扫描地图，对四个方向尝试移动（只是尝试！没有更新二维数数组中的数据！可以想想该怎么做！），如果有一个方向还可以移动，那么就未达到败局。如果四个方向都已经尝试过且无法移动，那么就已是败局，贴上游戏失败的图片</p>\n<h1 id=\"四、整体代码\"><a href=\"#四、整体代码\" class=\"headerlink\" title=\"四、整体代码\"></a>四、整体代码</h1><p>&emsp;1、头文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">ifndef</span> SMALLGAME</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> SMALLGAME</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;conio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdlib&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;graphics.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;ctime&gt;</span></span><br><span class=\"hljs-keyword\">extern</span> IMAGE img[<span class=\"hljs-number\">15</span>];<br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">map</span>[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">int</span> Imagine_number[<span class=\"hljs-number\">12</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Loadimage</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//加载所有的图片</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DrawMap</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//根据二维数组中的数据来贴上相应的图片</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">KeyDown</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//模拟按键</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">RandNum</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//在地图中随机产生数据</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveRight</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向右走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveLeft</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向左走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveUp</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向上走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveDown</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//向下走</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GAMEOVER</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PLAYERWIN</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ScanMap1</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ScanMap2</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ScanMap</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n<p>&emsp;2、源文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&quot;2048.h&quot;</span></span><br><span class=\"hljs-keyword\">int</span> Imagine_number[<span class=\"hljs-number\">12</span>]=&#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">64</span>,<span class=\"hljs-number\">128</span>,<span class=\"hljs-number\">256</span>,<span class=\"hljs-number\">512</span>,<span class=\"hljs-number\">1024</span>,<span class=\"hljs-number\">2048</span>&#125;;<br><span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">map</span>[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>]=&#123;<span class=\"hljs-number\">0</span>&#125;;<span class=\"hljs-comment\">//地图默认全部为0</span><br>IMAGE img[<span class=\"hljs-number\">15</span>];<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//主函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\tinitgraph(<span class=\"hljs-number\">240</span>,<span class=\"hljs-number\">300</span>);  <span class=\"hljs-comment\">//创建游戏窗体</span><br>\tLoadimage();<span class=\"hljs-comment\">//加载图片资源</span><br>\tDrawMap();<span class=\"hljs-comment\">//打印一遍默认的地图</span><br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> WINNERCHECK;<br>\t\tKeyDown();<span class=\"hljs-comment\">//按下按键</span><br>\t\tDrawMap();<span class=\"hljs-comment\">//打印一遍地图</span><br>\t\t<span class=\"hljs-keyword\">if</span> (ScanMap() == <span class=\"hljs-literal\">false</span>) &#123;<br>\t\t\tgetchar();<br>\t\t\tGAMEOVER();<br>\t\t\tsystem(<span class=\"hljs-string\">&quot;cls&quot;</span>);<br>\t\t\t<span class=\"hljs-comment\">//putimage(0, 0, img+14);</span><br>\t\t\tgetchar();<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\tWINNERCHECK= ScanMap2();<br>\t\t<span class=\"hljs-keyword\">if</span> (WINNERCHECK== <span class=\"hljs-number\">1</span>) &#123; putimage(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, img + <span class=\"hljs-number\">13</span>); <span class=\"hljs-keyword\">break</span>; &#125;<span class=\"hljs-comment\">//游戏获胜</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">//getchar();//暂停窗体</span><br>\t<span class=\"hljs-comment\">//closegraph();//关闭窗体</span><br>\tsystem(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//画地图</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DrawMap</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//画地图</span><br>\tsetbkcolor(RGB(<span class=\"hljs-number\">244</span>,<span class=\"hljs-number\">215</span>,<span class=\"hljs-number\">215</span>));  <span class=\"hljs-comment\">//设置窗体背景颜色</span><br>\tcleardevice();<span class=\"hljs-comment\">//更新一遍窗体</span><br>\tsettextcolor(WHITE);<span class=\"hljs-comment\">//设置文本数据</span><br>\tsettextstyle(<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&quot;楷体&quot;</span>);<br>\touttextxy(<span class=\"hljs-number\">50</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-string\">&quot;2048小游戏&quot;</span>);<br>\t<span class=\"hljs-keyword\">int</span> x,y,k;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\tx=<span class=\"hljs-number\">60</span>*j;<span class=\"hljs-comment\">//列</span><br>\t\t\ty=<span class=\"hljs-number\">60</span>*i+<span class=\"hljs-number\">60</span>;<span class=\"hljs-comment\">//行</span><br>\t\t\t<span class=\"hljs-comment\">//printf(&quot;%d %d\\n&quot;,x,y);</span><br>\t\t\t<span class=\"hljs-keyword\">for</span>(k = <span class=\"hljs-number\">0</span>;k &lt; <span class=\"hljs-number\">12</span>;k++)&#123;<span class=\"hljs-comment\">//遍历12张图片</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(Imagine_number[k] == <span class=\"hljs-built_in\">map</span>[i][j])<span class=\"hljs-comment\">//如果图片的标号等于地图中的数据</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//退出循环</span><br>\t\t\t&#125;<br>\t\t\tputimage(x,y,img+k);<span class=\"hljs-comment\">//在x,y的位置贴上第k章图</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//游戏结束</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GAMEOVER</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tclosegraph();<br>\tinitgraph(<span class=\"hljs-number\">240</span>, <span class=\"hljs-number\">300</span>);  <span class=\"hljs-comment\">//创建游戏窗体</span><br>\tputimage(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, img + <span class=\"hljs-number\">12</span>);<br>\tgetchar();<br>&#125; <br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//模拟按键</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">KeyDown</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> Key = _getch();<span class=\"hljs-comment\">//_getch()可以从键盘接受一个字符且不需要按enter键就可以执行</span><br>\t<span class=\"hljs-keyword\">switch</span>(Key)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;w&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;W&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span>  <span class=\"hljs-number\">72</span>:<br>\t\t\tRandNum();<span class=\"hljs-comment\">//每次移动都会伴随着移动</span><br>\t\t\tMoveUp();<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;s&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;S&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span>  <span class=\"hljs-number\">80</span>:<br>\t\t\tRandNum();<br>\t\t\tMoveDown();\t\t\t<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;A&#x27;</span>: <br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">75</span>:<br>\t\t\tRandNum();<br>\t\t\tMoveLeft();\t\t<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;d&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;D&#x27;</span>:<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">77</span>:<br>\t\t\tRandNum();<br>\t\t\tMoveRight();\t\t<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//加载图片</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> _CRT_SECURE_NO_WARNINGS <span class=\"hljs-comment\">//去掉sprintf内扩增的影响</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Loadimage</span><span class=\"hljs-params\">()</span></span>&#123;  <span class=\"hljs-comment\">//加载所有的图片</span><br>\tloadimage(img + <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&quot;111.jpg&quot;</span>);<br>\tloadimage(img + <span class=\"hljs-number\">13</span>, <span class=\"hljs-string\">&quot;12345.jpg&quot;</span>);<br>\tloadimage(img + <span class=\"hljs-number\">14</span>, <span class=\"hljs-string\">&quot;444.jpg&quot;</span>);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">12</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">char</span> FileName[<span class=\"hljs-number\">200</span>]=&#123;&#125;;<br>\t\t<span class=\"hljs-built_in\">sprintf</span>(FileName,<span class=\"hljs-string\">&quot;%d.jpg&quot;</span>,Imagine_number[i]);<br>\t\tloadimage(img + i,FileName);<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//移动</span><br><span class=\"hljs-comment\">//不同方向的移动</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveRight</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;  <span class=\"hljs-comment\">//判断是否可以合并</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>;j &gt;= <span class=\"hljs-number\">0</span>;j--)&#123;  <br>\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前的元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(NowKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">// 等于0的时候再去判断是没有意义的</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//列指针移动</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<span class=\"hljs-comment\">//取当前元素的下一个元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=-1;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>;j&gt;=<span class=\"hljs-number\">0</span>;j--)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t\t<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveLeft</span><span class=\"hljs-params\">()</span></span>&#123;  <span class=\"hljs-comment\">//向左走</span><br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(NowKey != <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &lt; <span class=\"hljs-number\">4</span>)&#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=4;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &lt; <span class=\"hljs-number\">4</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][k]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveUp</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123; <span class=\"hljs-comment\">//i是行 j是列</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] != <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &lt; <span class=\"hljs-number\">4</span>)&#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[k][j] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=4;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i+<span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &lt; <span class=\"hljs-number\">4</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[k][j] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[k][j]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MoveDown</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>;i &gt;= <span class=\"hljs-number\">0</span>;i--)&#123; <span class=\"hljs-comment\">//i是行 j是列</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(NowKey != <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey != <span class=\"hljs-number\">0</span>)&#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(NextKey == NowKey)&#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]*=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[k][j] = <span class=\"hljs-number\">0</span>;<br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=-1;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i<span class=\"hljs-number\">-1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span>(k &gt;= <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[k][j] != <span class=\"hljs-number\">0</span>)&#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j]=nowkeynext;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">map</span>[k][j]=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//生成随机数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">RandNum</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//在地图中随机产生数字</span><br>\tsrand((<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>)time(<span class=\"hljs-literal\">NULL</span>));<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">4</span>;i++)&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; <span class=\"hljs-number\">4</span>;j++)&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">map</span>[i][j] = (rand()%<span class=\"hljs-number\">3</span>)*<span class=\"hljs-number\">2</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">continue</span>;  <span class=\"hljs-comment\">//如果产生的随机数为0  那么就在其他的区域内继续产生随机数</span><br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//败局判断</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">ScanMap</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-comment\">/*向右走*/</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;  <span class=\"hljs-comment\">//判断是否可以合并</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>; j &gt;= <span class=\"hljs-number\">0</span>; j--) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前的元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (NowKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 等于0的时候再去判断是没有意义的</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &gt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//列指针移动</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<span class=\"hljs-comment\">//取当前元素的下一个元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey == NowKey) &#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] *= 2;//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][k] = 0;</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=-1;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">3</span>; j &gt;= <span class=\"hljs-number\">0</span>; j--) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j - <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] = nowkeynext;</span><br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][k] = 0; //非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">/*向左走*/</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (NowKey != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &lt; <span class=\"hljs-number\">4</span>) &#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey == NowKey) &#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">///map[i][j] *= 2;//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][k] = 0;</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=4;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = j + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &lt; <span class=\"hljs-number\">4</span>) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[i][k];<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][k] != <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] = nowkeynext;</span><br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][k] = 0; //非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">/*向上走*/</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123; <span class=\"hljs-comment\">//i是行 j是列</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &lt; <span class=\"hljs-number\">4</span>) &#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey == NowKey) &#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] *= 2;//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[k][j] = 0;</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=4;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &lt; <span class=\"hljs-number\">4</span>) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[k][j] != <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] = nowkeynext;</span><br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[k][j] = 0; //非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk++;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">/*向下走*/</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123; <span class=\"hljs-comment\">//i是行 j是列</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;  <span class=\"hljs-comment\">//遍历整个地图</span><br>\t\t\t<span class=\"hljs-keyword\">int</span> NowKey = <span class=\"hljs-built_in\">map</span>[i][j];<br>\t\t\t<span class=\"hljs-keyword\">if</span> (NowKey != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//</span><br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &gt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//不可以越界</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> NextKey = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey != <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">//如果下一个块已经有数据</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (NextKey == NowKey) &#123;  <span class=\"hljs-comment\">//如果下一块和当前块的数据是相同的</span><br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] *= 2;//那么就进行合并</span><br>\t\t\t\t\t\t\t<span class=\"hljs-comment\">//map[k][j] = 0;</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//k=-1;</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">//每次只能合并两个方块   </span><br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">3</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">int</span> nowkey = <span class=\"hljs-built_in\">map</span>[i][j];<span class=\"hljs-comment\">//取当前元素</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> k = i - <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">while</span> (k &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">int</span> nowkeynext = <span class=\"hljs-built_in\">map</span>[k][j];<span class=\"hljs-comment\">//取相同列的下一行元素</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[k][j] != <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//如果下一个元素不等于0,那么就需要进行合并的操作</span><br>\t\t\t\t\t\tflag = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[i][j] = nowkeynext;</span><br>\t\t\t\t\t\t<span class=\"hljs-comment\">//map[k][j] = 0; //非0元素移动之后重新置为0</span><br>\t\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tk--;<span class=\"hljs-comment\">//继续去判断其他的位置</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (flag == <span class=\"hljs-literal\">false</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br><br><span class=\"hljs-comment\">/*****************************************************/</span><br><span class=\"hljs-comment\">//胜局判断</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ScanMap2</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">3</span>; j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>[i][j] == <span class=\"hljs-number\">2048</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/*****************************************************/</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><p>&emsp;&emsp;进工作室以来第一次写小游戏。这一次写小游戏的过程中收获到了不少新东西：<br>&emsp;&emsp;&emsp;&emsp;1、<strong>Easyx的图形库的使用</strong><br>&emsp;&emsp;&emsp;&emsp;2、随机数的生成<br>&emsp;&emsp;&emsp;&emsp;3、_getch()和getchar()的区别<br>&emsp;&emsp;&emsp;&emsp;4、sprintf()的用法以及其不安全性<br>&emsp;&emsp;学会了Easyx的图形库以后可以学习做其他的小游戏。然后感觉自己还是有很多不会的东西。图书管理系统写了一小半但是感觉没有API的话写出来也没什么意思，等以后学了Java再继续完成吧。这学期剩下的时间好好复习的同时学习一点Linux服务器的知识，看能不能做出一个属于自己的博客吧！<br>&emsp;&emsp;冲冲冲！</p>\n<h1 id=\"六、工程项目代码以及小游戏exe文件下载\"><a href=\"#六、工程项目代码以及小游戏exe文件下载\" class=\"headerlink\" title=\"六、工程项目代码以及小游戏exe文件下载\"></a>六、工程项目代码以及小游戏exe文件下载</h1><p><del><strong>这是源代码</strong></del>——-&gt;<a href=\"https://github.com/yxr2333/Smallgame/blob/master/sourcecode--vs2019.rar\">源代码</a></p>\n<p><strong><del>这是exe文件</del></strong>———-&gt;<a href=\"https://github.com/yxr2333/Smallgame/blob/master/Smallgame.rar\">exe文件</a></p>\n","slug":"SmallGame","updated":"2020-12-12T10:08:19.842Z","comments":true,"link":"","permalink":"http://example.com/2020/12/11/SmallGame/","excerpt":"","categories":[{"name":"Game","slug":"Game","permalink":"http://example.com/categories/Game/"}],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"每周计划与周总结","date":"2020-12-10T12:54:02.000Z","path":"2020/12/10/Dayplan/","text":"暂时有自己的博客啦Yeah! 终于可以把每周的任务和总结搬上来了 让大家都来监督监督自己 呐下面就是我的周任务和总结啦 一、第十周1、第十周的周任务1、高数课 上 不定积分，好好听讲。 2、每天完成百词斩的记单词任务 3、完成excel作业 4、完成baby的媒体运营周任务 5、完成启明星工作室的关爱杯重赛的题目 6、高数作业 7、英语课后的翻译 8、划出英语unit3 textB 文章中5个比较重要的句子 9、就业指导课2000字手写论文 2、第十周的周总结​ 这一周过的挺快的，上一周我们C语言的老师就有通知过最近会进行专业的分流考试，所以辅导员通知的时候也不是特别惊讶。但总觉得现在分流感觉太早了，还没想好以后该走什么路，然后最后选择了计科作为第一志愿。下个星期还要找个时间去机房试一下学校的那个考试系统，熟悉一下操作之类的。高数这一周一直在上不定积分，我们的老师在这一章总算开始慢了下来，所以不定积分学的情况还可以吧。英语每天也在百词斩上进行了记单词，但到运用的时候第一反应还是一些基础的低级词汇，不能很好的运用到高级词汇来表达。不想最后被体育卡了学分，所以之前落下的阳光长跑和体测这一周也搞了一下。听说阳光长跑是到12月31号才结束，那争取跑满拿一下满分。工作室方面的话，这一周是完成了关爱杯重开里面的所有题目。主要学习到了博弈，vector容器和异或运算。用vector容器存储单词的话做关爱杯的G题会比较快（因为比较方便按照字典序排序）。下周的话，再坚持每天记单词打卡，然后做一下U校园上的测试，然后再就是去参加一下下周六的新生编程赛吧，希望可以获得好成绩。 二、第十一周1、第十一周的周任务1、高数课不定积分认真听讲，完成课后的习题任务 2、坚持每天记英语单词 3、媒体运营作业 4、启明星工作室大一月考核试题 5、背英语课文 6、完成学生成绩管理系统（用链表+分文件编写） 2、第十一周的周总结​ 感觉这一周过得真的特别快，可能是这一周的事情比较多吧。这一周主要是完成了分流考试和新生编程赛。新生编程赛的成绩不太理想吧，也看到了自己和其他人在比较复杂的问题的解决上还是有差距。高数的话这一周已经学完了不定积分，开始学定积分了。基础的题还行，要多多总结做题的方法。英语的单元quiz第一次做的太差了，让老师给重发了一下。已经重发了但是这周没有时间做，今天晚上找个时间做一下。C语言学习上这一周就学着手写了一下链表和如何使用extern变量。总体来说就感觉这周过得不是很满意吧，无论是学习上还是生活上，压力也感觉有点大，希望下一周能好好调整回来吧。 三、第十二周1、第十二周的周任务 时间 星期一 星期二 星期三 星期四 星期五 星期六 星期天 上午 英语课 周任务第一题 高数+C语言 Excel测试 高数课 英语课 去图书馆复习高数，为期末考试做准备 可以稍微起晚一点，9点多起床然后吃早饭来工作室，弄了一下键盘的宏键 下午 高数+C语言 肝PPT大赛的PPT 工训课（做了个太阳花结果搞掉了555） 不下雨的话进行体测，下雨的话就在工作室学习二叉树 C语言上机课顺便下课回去洗了个澡 复习高数补英语阅读写C语言上机课的作业 研究如何建立二叉树；写完了周任务的简单版 晚上 完成计算机学科概论的PPT 继续肝PPT+做高数作业 英语quiz 做星期五晚上演讲的PPT吧（虽然不知道这一周是否会轮到我） 来工作室拿电脑，思修课肝完了PPT大赛的东西 英语阅读 开周例会；听英语听力 1、完成媒体运营的论文 2、复习整理高数的知识点（至少整理完第一单元极限，有余力的话把第二单元的也整理一点） 3、每天坚持记英语单词 4、补上之前没有做的阅读作业 5、英语quiz给自己留一次重做的时间 6、学习一点新的数据结构吧，链表+二叉树（以写周任务的方式） 7、背英语的文章，为期末英语的口语考试做准备 2、第十二周的周总结​ 这一周的话主要是在忙着做PPT了，算下来这一周一共是做了3个PPT，计算机基础的，PPT大赛的，还有一个思修课演讲的PPT，做PPT的同时还学习了一下怎么样用Pr，Ps，Au，感觉这三个东西挺好用的，以后有时间的话也可以学一下。本周高数的话，有一节课听的时候效率挺低的，然后现在只能看看B站上面的视频补习一下了，另外周六的时候整理了一下高数第一章的知识点，算是为了期末考试做总结吧。英语的话这一周补了一下之前欠下的阅读，补了一半吧，晚上还要继续做一做。周任务的话，链表是之前就有看过的，写起来感觉还行。但是二叉树算是新接触吧，而且我对递归的理解真的很差，所以就觉得很难做。最后师傅把难度降低了，勉强的写完了。感觉自己的体质不咋样，准备锻炼锻炼身体了。马上要期末考试了，下一周要开始准备复习了。多看看递归的程序，加强一下对递归的理解吧。 四、第十三周 时间 星期一 星期二 星期三 星期四 星期五 星期六 星期天 上午 7点多起床；记单词； 尝试写双向链表构建图书管理系统 7点起床学习高数课 6：30起床10:00计算机基础课 高数课；英语课; 记单词完成PPT大赛的演讲稿 睡会懒觉 下午 高数课；整理思修课知识点；整理高数知识点 一套高数卷子英语阅读教程 工程基础训练 班上的团日活动 C语言上机课洗澡； PPT大赛决赛 复习高数英语 晚上 军事理论课；阳光打卡； 写图书管理系统提交PPT大赛的作品 整理高数课的内容（陪baby聊天了）(明天早上补齐没有完成的任务) 写2048小游戏 写思修课的演讲稿思修课演讲把小游戏完善写一下 完成2048小游戏 周例会；聚会； 1、第十三周的周任务 复习高数第二、三单元 给作品定一个大体的框架吧，然后写一下基础的部分 还是得坚持记单词 两天跑一次步 锻炼锻炼身体啊冲冲冲 多看看C++递归的程序，加深一下对递归的理解 学习双向链表的建立 整理高数不定积分和定积分知识点和解题方法 2、第十三周的周总结​ 马上到考试周了，感觉现在时间过得越来越快了。这一周周一是第一次上军事理论课， 结果忘记了然后急急忙忙跑过去发现是水课。马上到考试周了，比较担心自己的高数，就去打印店买了一套高数试卷，结果发现2018年的卷子压根没答案，就感觉挺难受的。星期四下午的时候班上举办了团日活动，给自闭症儿童进行募捐，最后募捐到了1000多，算是一下午的冷风没有白吹。星期四开始写答辩的小游戏，到今天下午把胜局判定和负局判定完成，小游戏才算正式完成了。下一周复习进度要继续推进了，复习的时候要重视课后习题。英语下一周开始复习，从第一单元开始背口语考试要求背的段落以及记每一章的单词。这一周（除了周日)都有在早起，下一周继续坚持。 五、第十四周 星期一 星期二 星期三 星期四 星期五 星期六 星期日 上午 1、试用服务器;2、英语课 1、给服务器配置环境2、体育期末考试 1、早上得记单词了 1、准备计算机概论的演讲 1、高数2、英语 1、补觉2、去丁老师家吃饭 1、完成高数2017年B卷 下午 1、高数课2、写博客 1、论文修改后再查重 1、工训课 1、复习高数 1、C语言上机课 2、部署好自己的Github博客 1、把小游戏的源码丢到Github上 1、做英语阅读2、完成英语Quiz3 晚上 1、军事理论课;2、给服务器安装宝塔 1、重新注册域名;2、完成一套高数卷子； 1、提交域名备案2、写高数作业 1、听学长讲Git 2、借助Github搭建自己的网站 1、思修课 1、复习高数 2、做英语阅读3、刷一套高数卷子 1、第十四周的周任务​ 1、和小赵合作完成8000字的论文 ​ 2、刷高数的卷子 ​ 3、模仿英语音频朗读口语考试内容 ​ 4、准备口语考试的内容 ​ 5、搭建自己的博客网站（域名需要备案导致可能得未完成了） ​ 6、搭建自己的Github博客 2、第十四周的周总结​ 这一周主要是在完成博客网站以及复习高数。自己的网站由于域名还没有批下来，而且iP+端口也访问不进去，所以还没有真正地进去玩过。 在学长刚讲完Git和Github之后，就感觉听的有点懵，各个分区都还没有弄明白。后来自己动手摸索，查博客。先结合学长给的资料搭建了基于Github的博客，更换了喜欢的主题，把一些总结和周计划文档都放在这个博客上面了。再因为当时在CSDN上发的博客并没有发布项目文件，就想着把项目文件传到Github的仓库里面然后贴个超链接上去。最后花了一下午才弄好，踩了不少坑，就比如配置好了密钥结果上传的时候发现Github限制文件大小100M。但踩着踩着现在大致就理清楚了。高数的话就刷期末的卷子吧，对答案的时候发现自己正确率确实不高，可能做卷子的时候不是很认真吧。下一周的任务就是继续复习了，域名下来的了的话就玩一下自己的网站。 六、第十五周 星期一 星期二 星期三 星期四 星期五 星期六 星期日 上午 1、英语听力课[√] 1、早起记单词2、体育课期末考试 1、高数课 1、上午去医院检查了腰部 1、高数课2、英语课 1、睡懒觉2、学习Python 1、解决nextcloud的403和404错误 下午 1、高数课[√]2、玩一下自己的网站[√] 1、 命令行搭建FTP服务器 1、工训课车辆工程 1、搭建了nextcloud的个人云盘2、复习最近学习的常微分方程内容 1、C语言上机课2、PPT期末测试 1、完善小游戏2、准备英语期末口语考试 1、复习高数2、准备明天的英语口语考试 晚上 1、军事理论课[ ]2、下课早的话就回工作室学习 [ ] 1、工作室学长讲课2、做英语阅读3、阳光打卡 1、完成体育的8000字论文 1、工作室学长讲Python2、装Linux系统 1、思修课（玩玩服务器吧） 1、第十五周的周任务 1、星期一课比较多大块的时间不是很多，上午英语听力课，下午高数课，域名终于批下来了，重新部署了一下自己的个人网站，进行了一定的美化，虽然还是很丑。。。晚上军事理论课如果没事的话可以做做高数啥的，下课下的早的话还是回工作室吧，今天阳光长跑需要打卡3次。 2、星期二课比较少就只有一节体育课。多练习了几次三级蛙跳虽然最后还是没及格但是比体测的时候1.44的成绩好太多了，也算是有很大进步吧。下午本来说是复习高数的后来忙着弄FTP服务器去了不知不觉地一下午就过去了，最后命令行配置FTP服务器还是失败了，害。晚上听学长讲了一下计算机硬件有关的知识，再通过宝塔把FTP服务器弄好了，做了做阅读，一天就这么结束了。 3、星期三课有点多，主要是下午是一下午的工训课。本来说早上是要来工作室记单词的，但实在是太困了而且体育课三级蛙跳把腰和大腿都有点拉伤了就没起来。今天一天走路都不舒服，害，所以下学期体育课千万不要选趣味田径。晚上的话心情不好，就把她的体育论文给写完吧，之前写到了6000字，正好今天晚上一晚上写完然后查个重，希望不要爆红。 4、星期四课算是比较少的了，上午腰实在是不舒服就请了假去医院拍了片子看了一下。所以说体育项目的话自己实在是没那个水准就不要强求自己，不然很容易受伤的。下午的话在工作室学习了一下午，完成了Nextcloud的部署，复习了高数balabala，晚上的话听工作室的学长讲爬虫，但是好困所以听的就不是很明白。装了个Linux系统，感觉Linux系统比Windows好看了不少，简洁了不少。 5、星期五的话课算不上多也算不上少吧，比前几天要稍微闲一点。下午上机课的时候把模拟cstring的几个库函数写了一下，然后把计算机基础的PPT测试刷到了满分。拿了好几个快递，晚上的话就放松休息一下，看看高数？玩玩服务器？聊聊天吧。 6、双休自然是没课的，上午睡了个懒觉，然后10点到的工作室，到了之后先学了一下Python的内容。后来想起自己的小游戏似乎还没有一个计算分数的功能，又去完善了一下。弄到了下午两点多钟差不多是全部弄完了 ，把英语的口语考试的题目准备一下吧，毕竟下周一就要考试了。 7、今天又是没课的一天，感觉效率不是很高呀，做事的时候不是很专注，总是想着做别的事去了。上午本来说是寝室的大扫除的，结果早上9点多了室友都还没有起来，最后实在等不了了，就出门了。来工作室以后先查博客解决了一下昨天遇到了403和404错误，问题就出在了没有配置好运行目录导致nginx没有办法访问到index.php等文件导致的。下午的话就做了做高数课本上的题目，然后准备了一下明天的英语口语考试。希望明天英语口语考试的时候，自己读慢一点，然后回答问题的时候不要紧张就好，加油。 2、第十五周的周总结考试时间记录1、英语时间：2020年1月2日 上午 9：00-11：00 地点：C-1117 2、C语言时间：2020年12月24日 晚上19:00~20:50 地点：J4机房 座位：039 3、高等数学（一）4、思修时间：2020/12/24 下午 14:00–15:40 地点：S-1631","raw":"---\ntitle: 每周计划与周总结\ncategories: 个人计划\ndate: 2020-12-10 20:54:02\ntags: \n\t- Plan\nexcerpt: 个人计划\n---\n\n\n\n~~暂时有自己的博客啦Yeah!~~\n\n~~终于可以把每周的任务和总结搬上来了~~\n\n**让大家都来监督监督自己**\n\n**呐下面就是我的周任务和总结啦**\n\n# 一、第十周\n\n## 1、第十周的周任务\n\n1、高数课 上  不定积分，好好听讲。 \n\n2、每天完成百词斩的记单词任务\n\n3、完成excel作业\n\n4、完成baby的媒体运营周任务\n\n5、完成启明星工作室的关爱杯重赛的题目\n\n6、高数作业\n\n7、英语课后的翻译\n\n8、划出英语unit3 textB 文章中5个比较重要的句子\n\n9、就业指导课2000字手写论文\n\n## 2、第十周的周总结\n\n​\t\t这一周过的挺快的，上一周我们C语言的老师就有通知过最近会进行专业的分流考试，所以辅导员通知的时候也不是特别惊讶。但总觉得现在分流感觉太早了，还没想好以后该走什么路，然后最后选择了计科作为第一志愿。下个星期还要找个时间去机房试一下学校的那个考试系统，熟悉一下操作之类的。高数这一周一直在上不定积分，我们的老师在这一章总算开始慢了下来，所以不定积分学的情况还可以吧。英语每天也在百词斩上进行了记单词，但到运用的时候第一反应还是一些基础的低级词汇，不能很好的运用到高级词汇来表达。不想最后被体育卡了学分，所以之前落下的阳光长跑和体测这一周也搞了一下。听说阳光长跑是到12月31号才结束，那争取跑满拿一下满分。工作室方面的话，这一周是完成了关爱杯重开里面的所有题目。主要学习到了博弈，vector容器和异或运算。用vector容器存储单词的话做关爱杯的G题会比较快（因为比较方便按照字典序排序）。下周的话，再坚持每天记单词打卡，然后做一下U校园上的测试，然后再就是去参加一下下周六的新生编程赛吧，希望可以获得好成绩。\n\n# 二、第十一周\n\n## 1、第十一周的周任务\n\n1、高数课不定积分认真听讲，完成课后的习题任务\n\n2、坚持每天记英语单词\n\n3、媒体运营作业\n\n4、启明星工作室大一月考核试题\n\n5、背英语课文\n\n6、完成学生成绩管理系统（用链表+分文件编写）\n\n## 2、第十一周的周总结\n\n​\t\t感觉这一周过得真的特别快，可能是这一周的事情比较多吧。这一周主要是完成了分流考试和新生编程赛。新生编程赛的成绩不太理想吧，也看到了自己和其他人在比较复杂的问题的解决上还是有差距。高数的话这一周已经学完了不定积分，开始学定积分了。基础的题还行，要多多总结做题的方法。英语的单元quiz第一次做的太差了，让老师给重发了一下。已经重发了但是这周没有时间做，今天晚上找个时间做一下。C语言学习上这一周就学着手写了一下链表和如何使用extern变量。总体来说就感觉这周过得不是很满意吧，无论是学习上还是生活上，压力也感觉有点大，希望下一周能好好调整回来吧。\n\n# 三、第十二周\n\n## 1、第十二周的周任务\n\n| 时间 |         星期一          |        星期二        |               星期三                |                         星期四                          |                  星期五                   |                    星期六                     |                            星期天                            |\n| :--: | :---------------------: | :------------------: | :---------------------------------: | :-----------------------------------------------------: | :---------------------------------------: | :-------------------------------------------: | :----------------------------------------------------------: |\n| 上午 |         英语课          |     周任务第一题     |             高数+C语言              |                        Excel测试                        |              高数课  英语课               |      去图书馆复习高数，为期末考试做准备       | 可以稍微起晚一点，9点多起床然后吃早饭来工作室，弄了一下键盘的宏键 |\n| 下午 |       高数+C语言        |    肝PPT大赛的PPT    | 工训课（做了个太阳花结果搞掉了555） |    不下雨的话进行体测，下雨的话就在工作室学习二叉树     |      C语言上机课顺便下课回去洗了个澡      | 复习高数<br>补英语阅读<br>写C语言上机课的作业 |         研究如何建立二叉树；<br>写完了周任务的简单版         |\n| 晚上 | 完成计算机学科概论的PPT | 继续肝PPT+做高数作业 |              英语quiz               | 做星期五晚上演讲的PPT吧（虽然不知道这一周是否会轮到我） | 来工作室拿电脑，思修课肝完了PPT大赛的东西 |                   英语阅读                    |                   开周例会；<br>听英语听力                   |\n\n1、完成媒体运营的论文\n\n2、复习整理高数的知识点（至少整理完第一单元极限，有余力的话把第二单元的也整理一点）\n\n3、每天坚持记英语单词\n\n4、补上之前没有做的阅读作业\n\n5、英语quiz给自己留一次重做的时间\n\n6、学习一点新的数据结构吧，链表+二叉树（以写周任务的方式）\n\n7、背英语的文章，为期末英语的口语考试做准备\n\n## 2、第十二周的周总结\n\n​\t\t\t这一周的话主要是在忙着做PPT了，算下来这一周一共是做了3个PPT，计算机基础的，PPT大赛的，还有一个思修课演讲的PPT，做PPT的同时还学习了一下怎么样用Pr，Ps，Au，感觉这三个东西挺好用的，以后有时间的话也可以学一下。本周高数的话，有一节课听的时候效率挺低的，然后现在只能看看B站上面的视频补习一下了，另外周六的时候整理了一下高数第一章的知识点，算是为了期末考试做总结吧。英语的话这一周补了一下之前欠下的阅读，补了一半吧，晚上还要继续做一做。周任务的话，链表是之前就有看过的，写起来感觉还行。但是二叉树算是新接触吧，而且我对递归的理解真的很差，所以就觉得很难做。最后师傅把难度降低了，勉强的写完了。感觉自己的体质不咋样，准备锻炼锻炼身体了。马上要期末考试了，下一周要开始准备复习了。多看看递归的程序，加强一下对递归的理解吧。\n\n# 四、第十三周\n\n| 时间 |                      星期一                      |                 星期二                 |                            星期三                            |             星期四             |                        星期五                        |            星期六             |     星期天     |\n| :--: | :----------------------------------------------: | :------------------------------------: | :----------------------------------------------------------: | :----------------------------: | :--------------------------------------------------: | :---------------------------: | :------------: |\n| 上午 |             7点多起床；<br>记单词；              | 尝试写双向链表<br>构建图书管理系统<br> |                    7点起床学习<br>高数课                     | 6：30起床<br>10:00计算机基础课 |                 高数课；<br>英语课;                  | 记单词<br>完成PPT大赛的演讲稿 |    睡会懒觉    |\n| 下午 | 高数课；<br>整理思修课知识点；<br>整理高数知识点 |    一套高数卷子<br>英语阅读教程<br>    |                         工程基础训练                         |         班上的团日活动         |                C语言上机课<br>洗澡；                 |          PPT大赛决赛          |  复习高数英语  |\n| 晚上 |            军事理论课；<br>阳光打卡；            |  写图书管理系统<br>提交PPT大赛的作品   | 整理高数课的内容<br>（陪baby聊天了）<br>(明天早上补齐没有完成的任务) |          写2048小游戏          | 写思修课的演讲稿<br>思修课演讲<br>把小游戏完善写一下 |        完成2048小游戏         | 周例会；聚会； |\n\n## 1、第十三周的周任务\n\n- 复习高数第二、三单元\n- 给作品定一个大体的框架吧，然后写一下基础的部分\n- 还是得坚持记单词\n- 两天跑一次步  锻炼锻炼身体啊冲冲冲\n- 多看看C++递归的程序，加深一下对递归的理解\n- 学习双向链表的建立\n- 整理高数不定积分和定积分知识点和解题方法\n\n## 2、第十三周的周总结\n\n​\t  \t马上到考试周了，感觉现在时间过得越来越快了。这一周周一是第一次上军事理论课， 结果忘记了然后急急忙忙跑过去发现是水课。马上到考试周了，比较担心自己的高数，就去打印店买了一套高数试卷，结果发现2018年的卷子压根没答案，就感觉挺难受的。星期四下午的时候班上举办了团日活动，给自闭症儿童进行募捐，最后募捐到了1000多，算是一下午的冷风没有白吹。星期四开始写答辩的小游戏，到今天下午把胜局判定和负局判定完成，小游戏才算正式完成了。下一周复习进度要继续推进了，复习的时候要重视课后习题。英语下一周开始复习，从第一单元开始背口语考试要求背的段落以及记每一章的单词。这一周（除了周日)都有在早起，下一周继续坚持。\n\n# 五、第十四周\n\n|          |                星期一                 |                  星期二                   |              星期三              |                      星期四                      |                     星期五                     |                       星期六                        |              星期日               |\n| :------: | :-----------------------------------: | :---------------------------------------: | :------------------------------: | :----------------------------------------------: | :--------------------------------------------: | :-------------------------------------------------: | :-------------------------------: |\n| **上午** |      1、试用服务器;<br>2、英语课      |  1、给服务器配置环境<br>2、体育期末考试   |        1、早上得记单词了         |             1、准备计算机概论的演讲              |               1、高数<br>2、英语               |            1、补觉<br>2、去丁老师家吃饭             |       1、完成高数2017年B卷        |\n| **下午** |        1、高数课<br/>2、写博客        |          1、论文修改后再查重<br>          |            1、工训课             |                   1、复习高数                    | 1、C语言上机课  <br/>2、部署好自己的Github博客 |            1、把小游戏的源码丢到Github上            | 1、做英语阅读<br>2、完成英语Quiz3 |\n| **晚上** | 1、军事理论课;<br>2、给服务器安装宝塔 | 1、重新注册域名;<br>2、完成一套高数卷子； | 1、提交域名备案<br>2、写高数作业 | 1、听学长讲Git<br>   2、借助Github搭建自己的网站 |                   1、思修课                    | 1、复习高数<br>  2、做英语阅读<br>3、刷一套高数卷子 |                                   |\n\n\n\n## 1、第十四周的周任务\n\n​\t1、和小赵合作完成8000字的论文\n\n​\t2、刷高数的卷子\n\n​\t3、模仿英语音频朗读口语考试内容\n\n​\t4、准备口语考试的内容\n\n​\t5、搭建自己的博客网站（域名需要备案导致可能得未完成了）\n\n​\t6、搭建自己的Github博客\n\n## 2、第十四周的周总结\n\n\n\n​\t\t这一周主要是在完成博客网站以及复习高数。自己的网站由于域名还没有批下来，而且iP+端口也访问不进去，所以还没有真正地进去玩过。 在学长刚讲完Git和Github之后，就感觉听的有点懵，各个分区都还没有弄明白。后来自己动手摸索，查博客。先结合学长给的资料搭建了基于Github的博客，更换了喜欢的主题，把一些总结和周计划文档都放在这个博客上面了。再因为当时在CSDN上发的博客并没有发布项目文件，就想着把项目文件传到Github的仓库里面然后贴个超链接上去。最后花了一下午才弄好，踩了不少坑，就比如配置好了密钥结果上传的时候发现Github限制文件大小100M。但踩着踩着现在大致就理清楚了。高数的话就刷期末的卷子吧，对答案的时候发现自己正确率确实不高，可能做卷子的时候不是很认真吧。下一周的任务就是继续复习了，域名下来的了的话就玩一下自己的网站。\n\n# 六、第十五周\n\n|          |                        星期一                        |                      星期二                       |         星期三          |                            星期四                            |              星期五              |                  星期六                  |                  星期日                  |\n| :------: | :--------------------------------------------------: | :-----------------------------------------------: | :---------------------: | :----------------------------------------------------------: | :------------------------------: | :--------------------------------------: | :--------------------------------------: |\n| **上午** |                   1、英语听力课[√]                   |        1、早起记单词<br>2、体育课期末考试         |        1、高数课        |                   1、上午去医院检查了腰部                    |      1、高数课<br>2、英语课      |        1、睡懒觉<br>2、学习Python        |      1、解决nextcloud的403和404错误      |\n| **下午** |        1、高数课[√]<br>2、玩一下自己的网站[√]        |              1、 命令行搭建FTP服务器              |  1、工训课<br>车辆工程  | 1、搭建了nextcloud的个人云盘<br>2、复习最近学习的常微分方程内容 | 1、C语言上机课<br>2、PPT期末测试 | 1、完善小游戏<br>2、准备英语期末口语考试 | 1、复习高数<br>2、准备明天的英语口语考试 |\n| **晚上** | 1、军事理论课[ ]<br>2、下课早的话就回工作室学习  [ ] | 1、工作室学长讲课<br>2、做英语阅读<br>3、阳光打卡 | 1、完成体育的8000字论文 |           1、工作室学长讲Python<br>2、装Linux系统            |    1、思修课（玩玩服务器吧）     |                                          |                                          |\n\n## 1、第十五周的周任务\n\n- [x] 1、星期一课比较多大块的时间不是很多，上午英语听力课，下午高数课，域名终于批下来了，重新部署了一下自己的个人网站，进行了一定的美化，虽然还是很丑。。。晚上军事理论课如果没事的话可以做做高数啥的，下课下的早的话还是回工作室吧，今天阳光长跑需要打卡3次。\n- [x] 2、星期二课比较少就只有一节体育课。多练习了几次三级蛙跳虽然最后还是没及格但是比体测的时候1.44的成绩好太多了，也算是有很大进步吧。下午本来说是复习高数的后来忙着弄FTP服务器去了不知不觉地一下午就过去了，最后命令行配置FTP服务器还是失败了，害。晚上听学长讲了一下计算机硬件有关的知识，再通过宝塔把FTP服务器弄好了，做了做阅读，一天就这么结束了。\n- [x] 3、星期三课有点多，主要是下午是一下午的工训课。本来说早上是要来工作室记单词的，但实在是太困了而且体育课三级蛙跳把腰和大腿都有点拉伤了就没起来。今天一天走路都不舒服，害，所以下学期体育课千万不要选趣味田径。晚上的话心情不好，就把她的体育论文给写完吧，之前写到了6000字，正好今天晚上一晚上写完然后查个重，希望不要爆红。\n- [x] 4、星期四课算是比较少的了，上午腰实在是不舒服就请了假去医院拍了片子看了一下。所以说体育项目的话自己实在是没那个水准就不要强求自己，不然很容易受伤的。下午的话在工作室学习了一下午，完成了Nextcloud的部署，复习了高数balabala，晚上的话听工作室的学长讲爬虫，但是好困所以听的就不是很明白。装了个Linux系统，感觉Linux系统比Windows好看了不少，简洁了不少。\n- [x] 5、星期五的话课算不上多也算不上少吧，比前几天要稍微闲一点。下午上机课的时候把模拟cstring的几个库函数写了一下，然后把计算机基础的PPT测试刷到了满分。拿了好几个快递，晚上的话就放松休息一下，看看高数？玩玩服务器？聊聊天吧。\n- [x] 6、双休自然是没课的，上午睡了个懒觉，然后10点到的工作室，到了之后先学了一下Python的内容。后来想起自己的小游戏似乎还没有一个计算分数的功能，又去完善了一下。弄到了下午两点多钟差不多是全部弄完了 ，把英语的口语考试的题目准备一下吧，毕竟下周一就要考试了。\n- [x] 7、今天又是没课的一天，感觉效率不是很高呀，做事的时候不是很专注，总是想着做别的事去了。上午本来说是寝室的大扫除的，结果早上9点多了室友都还没有起来，最后实在等不了了，就出门了。来工作室以后先查博客解决了一下昨天遇到了403和404错误，问题就出在了没有配置好运行目录导致nginx没有办法访问到index.php等文件导致的。下午的话就做了做高数课本上的题目，然后准备了一下明天的英语口语考试。希望明天英语口语考试的时候，自己读慢一点，然后回答问题的时候不要紧张就好，加油。\n\n## 2、第十五周的周总结\n\n\n\n\n\n\n\n\n\n\n\n# 考试时间记录\n\n## 1、英语\n\n**时间：**2020年1月2日  **上午 9：00-11：00**\n\n**地点：**C-1117\n\n## 2、C语言\n\n**时间：**2020年12月24日 **晚上19:00~20:50**\n\n**地点：**J4机房\n\n**座位：**039\n\n## 3、高等数学（一）\n\n## 4、思修\n\n**时间：**2020/12/24  **下午 14:00--15:40** \n\n**地点：**S-1631\n\n\n\n","content":"<p><del>暂时有自己的博客啦Yeah!</del></p>\n<p><del>终于可以把每周的任务和总结搬上来了</del></p>\n<p><strong>让大家都来监督监督自己</strong></p>\n<p><strong>呐下面就是我的周任务和总结啦</strong></p>\n<h1 id=\"一、第十周\"><a href=\"#一、第十周\" class=\"headerlink\" title=\"一、第十周\"></a>一、第十周</h1><h2 id=\"1、第十周的周任务\"><a href=\"#1、第十周的周任务\" class=\"headerlink\" title=\"1、第十周的周任务\"></a>1、第十周的周任务</h2><p>1、高数课 上  不定积分，好好听讲。 </p>\n<p>2、每天完成百词斩的记单词任务</p>\n<p>3、完成excel作业</p>\n<p>4、完成baby的媒体运营周任务</p>\n<p>5、完成启明星工作室的关爱杯重赛的题目</p>\n<p>6、高数作业</p>\n<p>7、英语课后的翻译</p>\n<p>8、划出英语unit3 textB 文章中5个比较重要的句子</p>\n<p>9、就业指导课2000字手写论文</p>\n<h2 id=\"2、第十周的周总结\"><a href=\"#2、第十周的周总结\" class=\"headerlink\" title=\"2、第十周的周总结\"></a>2、第十周的周总结</h2><p>​        这一周过的挺快的，上一周我们C语言的老师就有通知过最近会进行专业的分流考试，所以辅导员通知的时候也不是特别惊讶。但总觉得现在分流感觉太早了，还没想好以后该走什么路，然后最后选择了计科作为第一志愿。下个星期还要找个时间去机房试一下学校的那个考试系统，熟悉一下操作之类的。高数这一周一直在上不定积分，我们的老师在这一章总算开始慢了下来，所以不定积分学的情况还可以吧。英语每天也在百词斩上进行了记单词，但到运用的时候第一反应还是一些基础的低级词汇，不能很好的运用到高级词汇来表达。不想最后被体育卡了学分，所以之前落下的阳光长跑和体测这一周也搞了一下。听说阳光长跑是到12月31号才结束，那争取跑满拿一下满分。工作室方面的话，这一周是完成了关爱杯重开里面的所有题目。主要学习到了博弈，vector容器和异或运算。用vector容器存储单词的话做关爱杯的G题会比较快（因为比较方便按照字典序排序）。下周的话，再坚持每天记单词打卡，然后做一下U校园上的测试，然后再就是去参加一下下周六的新生编程赛吧，希望可以获得好成绩。</p>\n<h1 id=\"二、第十一周\"><a href=\"#二、第十一周\" class=\"headerlink\" title=\"二、第十一周\"></a>二、第十一周</h1><h2 id=\"1、第十一周的周任务\"><a href=\"#1、第十一周的周任务\" class=\"headerlink\" title=\"1、第十一周的周任务\"></a>1、第十一周的周任务</h2><p>1、高数课不定积分认真听讲，完成课后的习题任务</p>\n<p>2、坚持每天记英语单词</p>\n<p>3、媒体运营作业</p>\n<p>4、启明星工作室大一月考核试题</p>\n<p>5、背英语课文</p>\n<p>6、完成学生成绩管理系统（用链表+分文件编写）</p>\n<h2 id=\"2、第十一周的周总结\"><a href=\"#2、第十一周的周总结\" class=\"headerlink\" title=\"2、第十一周的周总结\"></a>2、第十一周的周总结</h2><p>​        感觉这一周过得真的特别快，可能是这一周的事情比较多吧。这一周主要是完成了分流考试和新生编程赛。新生编程赛的成绩不太理想吧，也看到了自己和其他人在比较复杂的问题的解决上还是有差距。高数的话这一周已经学完了不定积分，开始学定积分了。基础的题还行，要多多总结做题的方法。英语的单元quiz第一次做的太差了，让老师给重发了一下。已经重发了但是这周没有时间做，今天晚上找个时间做一下。C语言学习上这一周就学着手写了一下链表和如何使用extern变量。总体来说就感觉这周过得不是很满意吧，无论是学习上还是生活上，压力也感觉有点大，希望下一周能好好调整回来吧。</p>\n<h1 id=\"三、第十二周\"><a href=\"#三、第十二周\" class=\"headerlink\" title=\"三、第十二周\"></a>三、第十二周</h1><h2 id=\"1、第十二周的周任务\"><a href=\"#1、第十二周的周任务\" class=\"headerlink\" title=\"1、第十二周的周任务\"></a>1、第十二周的周任务</h2><table>\n<thead>\n<tr>\n<th align=\"center\">时间</th>\n<th align=\"center\">星期一</th>\n<th align=\"center\">星期二</th>\n<th align=\"center\">星期三</th>\n<th align=\"center\">星期四</th>\n<th align=\"center\">星期五</th>\n<th align=\"center\">星期六</th>\n<th align=\"center\">星期天</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">上午</td>\n<td align=\"center\">英语课</td>\n<td align=\"center\">周任务第一题</td>\n<td align=\"center\">高数+C语言</td>\n<td align=\"center\">Excel测试</td>\n<td align=\"center\">高数课  英语课</td>\n<td align=\"center\">去图书馆复习高数，为期末考试做准备</td>\n<td align=\"center\">可以稍微起晚一点，9点多起床然后吃早饭来工作室，弄了一下键盘的宏键</td>\n</tr>\n<tr>\n<td align=\"center\">下午</td>\n<td align=\"center\">高数+C语言</td>\n<td align=\"center\">肝PPT大赛的PPT</td>\n<td align=\"center\">工训课（做了个太阳花结果搞掉了555）</td>\n<td align=\"center\">不下雨的话进行体测，下雨的话就在工作室学习二叉树</td>\n<td align=\"center\">C语言上机课顺便下课回去洗了个澡</td>\n<td align=\"center\">复习高数<br>补英语阅读<br>写C语言上机课的作业</td>\n<td align=\"center\">研究如何建立二叉树；<br>写完了周任务的简单版</td>\n</tr>\n<tr>\n<td align=\"center\">晚上</td>\n<td align=\"center\">完成计算机学科概论的PPT</td>\n<td align=\"center\">继续肝PPT+做高数作业</td>\n<td align=\"center\">英语quiz</td>\n<td align=\"center\">做星期五晚上演讲的PPT吧（虽然不知道这一周是否会轮到我）</td>\n<td align=\"center\">来工作室拿电脑，思修课肝完了PPT大赛的东西</td>\n<td align=\"center\">英语阅读</td>\n<td align=\"center\">开周例会；<br>听英语听力</td>\n</tr>\n</tbody></table>\n<p>1、完成媒体运营的论文</p>\n<p>2、复习整理高数的知识点（至少整理完第一单元极限，有余力的话把第二单元的也整理一点）</p>\n<p>3、每天坚持记英语单词</p>\n<p>4、补上之前没有做的阅读作业</p>\n<p>5、英语quiz给自己留一次重做的时间</p>\n<p>6、学习一点新的数据结构吧，链表+二叉树（以写周任务的方式）</p>\n<p>7、背英语的文章，为期末英语的口语考试做准备</p>\n<h2 id=\"2、第十二周的周总结\"><a href=\"#2、第十二周的周总结\" class=\"headerlink\" title=\"2、第十二周的周总结\"></a>2、第十二周的周总结</h2><p>​            这一周的话主要是在忙着做PPT了，算下来这一周一共是做了3个PPT，计算机基础的，PPT大赛的，还有一个思修课演讲的PPT，做PPT的同时还学习了一下怎么样用Pr，Ps，Au，感觉这三个东西挺好用的，以后有时间的话也可以学一下。本周高数的话，有一节课听的时候效率挺低的，然后现在只能看看B站上面的视频补习一下了，另外周六的时候整理了一下高数第一章的知识点，算是为了期末考试做总结吧。英语的话这一周补了一下之前欠下的阅读，补了一半吧，晚上还要继续做一做。周任务的话，链表是之前就有看过的，写起来感觉还行。但是二叉树算是新接触吧，而且我对递归的理解真的很差，所以就觉得很难做。最后师傅把难度降低了，勉强的写完了。感觉自己的体质不咋样，准备锻炼锻炼身体了。马上要期末考试了，下一周要开始准备复习了。多看看递归的程序，加强一下对递归的理解吧。</p>\n<h1 id=\"四、第十三周\"><a href=\"#四、第十三周\" class=\"headerlink\" title=\"四、第十三周\"></a>四、第十三周</h1><table>\n<thead>\n<tr>\n<th align=\"center\">时间</th>\n<th align=\"center\">星期一</th>\n<th align=\"center\">星期二</th>\n<th align=\"center\">星期三</th>\n<th align=\"center\">星期四</th>\n<th align=\"center\">星期五</th>\n<th align=\"center\">星期六</th>\n<th align=\"center\">星期天</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">上午</td>\n<td align=\"center\">7点多起床；<br>记单词；</td>\n<td align=\"center\">尝试写双向链表<br>构建图书管理系统<br></td>\n<td align=\"center\">7点起床学习<br>高数课</td>\n<td align=\"center\">6：30起床<br>10:00计算机基础课</td>\n<td align=\"center\">高数课；<br>英语课;</td>\n<td align=\"center\">记单词<br>完成PPT大赛的演讲稿</td>\n<td align=\"center\">睡会懒觉</td>\n</tr>\n<tr>\n<td align=\"center\">下午</td>\n<td align=\"center\">高数课；<br>整理思修课知识点；<br>整理高数知识点</td>\n<td align=\"center\">一套高数卷子<br>英语阅读教程<br></td>\n<td align=\"center\">工程基础训练</td>\n<td align=\"center\">班上的团日活动</td>\n<td align=\"center\">C语言上机课<br>洗澡；</td>\n<td align=\"center\">PPT大赛决赛</td>\n<td align=\"center\">复习高数英语</td>\n</tr>\n<tr>\n<td align=\"center\">晚上</td>\n<td align=\"center\">军事理论课；<br>阳光打卡；</td>\n<td align=\"center\">写图书管理系统<br>提交PPT大赛的作品</td>\n<td align=\"center\">整理高数课的内容<br>（陪baby聊天了）<br>(明天早上补齐没有完成的任务)</td>\n<td align=\"center\">写2048小游戏</td>\n<td align=\"center\">写思修课的演讲稿<br>思修课演讲<br>把小游戏完善写一下</td>\n<td align=\"center\">完成2048小游戏</td>\n<td align=\"center\">周例会；聚会；</td>\n</tr>\n</tbody></table>\n<h2 id=\"1、第十三周的周任务\"><a href=\"#1、第十三周的周任务\" class=\"headerlink\" title=\"1、第十三周的周任务\"></a>1、第十三周的周任务</h2><ul>\n<li>复习高数第二、三单元</li>\n<li>给作品定一个大体的框架吧，然后写一下基础的部分</li>\n<li>还是得坚持记单词</li>\n<li>两天跑一次步  锻炼锻炼身体啊冲冲冲</li>\n<li>多看看C++递归的程序，加深一下对递归的理解</li>\n<li>学习双向链表的建立</li>\n<li>整理高数不定积分和定积分知识点和解题方法</li>\n</ul>\n<h2 id=\"2、第十三周的周总结\"><a href=\"#2、第十三周的周总结\" class=\"headerlink\" title=\"2、第十三周的周总结\"></a>2、第十三周的周总结</h2><p>​          马上到考试周了，感觉现在时间过得越来越快了。这一周周一是第一次上军事理论课， 结果忘记了然后急急忙忙跑过去发现是水课。马上到考试周了，比较担心自己的高数，就去打印店买了一套高数试卷，结果发现2018年的卷子压根没答案，就感觉挺难受的。星期四下午的时候班上举办了团日活动，给自闭症儿童进行募捐，最后募捐到了1000多，算是一下午的冷风没有白吹。星期四开始写答辩的小游戏，到今天下午把胜局判定和负局判定完成，小游戏才算正式完成了。下一周复习进度要继续推进了，复习的时候要重视课后习题。英语下一周开始复习，从第一单元开始背口语考试要求背的段落以及记每一章的单词。这一周（除了周日)都有在早起，下一周继续坚持。</p>\n<h1 id=\"五、第十四周\"><a href=\"#五、第十四周\" class=\"headerlink\" title=\"五、第十四周\"></a>五、第十四周</h1><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">星期一</th>\n<th align=\"center\">星期二</th>\n<th align=\"center\">星期三</th>\n<th align=\"center\">星期四</th>\n<th align=\"center\">星期五</th>\n<th align=\"center\">星期六</th>\n<th align=\"center\">星期日</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>上午</strong></td>\n<td align=\"center\">1、试用服务器;<br>2、英语课</td>\n<td align=\"center\">1、给服务器配置环境<br>2、体育期末考试</td>\n<td align=\"center\">1、早上得记单词了</td>\n<td align=\"center\">1、准备计算机概论的演讲</td>\n<td align=\"center\">1、高数<br>2、英语</td>\n<td align=\"center\">1、补觉<br>2、去丁老师家吃饭</td>\n<td align=\"center\">1、完成高数2017年B卷</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>下午</strong></td>\n<td align=\"center\">1、高数课<br/>2、写博客</td>\n<td align=\"center\">1、论文修改后再查重<br></td>\n<td align=\"center\">1、工训课</td>\n<td align=\"center\">1、复习高数</td>\n<td align=\"center\">1、C语言上机课  <br/>2、部署好自己的Github博客</td>\n<td align=\"center\">1、把小游戏的源码丢到Github上</td>\n<td align=\"center\">1、做英语阅读<br>2、完成英语Quiz3</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>晚上</strong></td>\n<td align=\"center\">1、军事理论课;<br>2、给服务器安装宝塔</td>\n<td align=\"center\">1、重新注册域名;<br>2、完成一套高数卷子；</td>\n<td align=\"center\">1、提交域名备案<br>2、写高数作业</td>\n<td align=\"center\">1、听学长讲Git<br>   2、借助Github搭建自己的网站</td>\n<td align=\"center\">1、思修课</td>\n<td align=\"center\">1、复习高数<br>  2、做英语阅读<br>3、刷一套高数卷子</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"1、第十四周的周任务\"><a href=\"#1、第十四周的周任务\" class=\"headerlink\" title=\"1、第十四周的周任务\"></a>1、第十四周的周任务</h2><p>​    1、和小赵合作完成8000字的论文</p>\n<p>​    2、刷高数的卷子</p>\n<p>​    3、模仿英语音频朗读口语考试内容</p>\n<p>​    4、准备口语考试的内容</p>\n<p>​    5、搭建自己的博客网站（域名需要备案导致可能得未完成了）</p>\n<p>​    6、搭建自己的Github博客</p>\n<h2 id=\"2、第十四周的周总结\"><a href=\"#2、第十四周的周总结\" class=\"headerlink\" title=\"2、第十四周的周总结\"></a>2、第十四周的周总结</h2><p>​        这一周主要是在完成博客网站以及复习高数。自己的网站由于域名还没有批下来，而且iP+端口也访问不进去，所以还没有真正地进去玩过。 在学长刚讲完Git和Github之后，就感觉听的有点懵，各个分区都还没有弄明白。后来自己动手摸索，查博客。先结合学长给的资料搭建了基于Github的博客，更换了喜欢的主题，把一些总结和周计划文档都放在这个博客上面了。再因为当时在CSDN上发的博客并没有发布项目文件，就想着把项目文件传到Github的仓库里面然后贴个超链接上去。最后花了一下午才弄好，踩了不少坑，就比如配置好了密钥结果上传的时候发现Github限制文件大小100M。但踩着踩着现在大致就理清楚了。高数的话就刷期末的卷子吧，对答案的时候发现自己正确率确实不高，可能做卷子的时候不是很认真吧。下一周的任务就是继续复习了，域名下来的了的话就玩一下自己的网站。</p>\n<h1 id=\"六、第十五周\"><a href=\"#六、第十五周\" class=\"headerlink\" title=\"六、第十五周\"></a>六、第十五周</h1><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">星期一</th>\n<th align=\"center\">星期二</th>\n<th align=\"center\">星期三</th>\n<th align=\"center\">星期四</th>\n<th align=\"center\">星期五</th>\n<th align=\"center\">星期六</th>\n<th align=\"center\">星期日</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>上午</strong></td>\n<td align=\"center\">1、英语听力课[√]</td>\n<td align=\"center\">1、早起记单词<br>2、体育课期末考试</td>\n<td align=\"center\">1、高数课</td>\n<td align=\"center\">1、上午去医院检查了腰部</td>\n<td align=\"center\">1、高数课<br>2、英语课</td>\n<td align=\"center\">1、睡懒觉<br>2、学习Python</td>\n<td align=\"center\">1、解决nextcloud的403和404错误</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>下午</strong></td>\n<td align=\"center\">1、高数课[√]<br>2、玩一下自己的网站[√]</td>\n<td align=\"center\">1、 命令行搭建FTP服务器</td>\n<td align=\"center\">1、工训课<br>车辆工程</td>\n<td align=\"center\">1、搭建了nextcloud的个人云盘<br>2、复习最近学习的常微分方程内容</td>\n<td align=\"center\">1、C语言上机课<br>2、PPT期末测试</td>\n<td align=\"center\">1、完善小游戏<br>2、准备英语期末口语考试</td>\n<td align=\"center\">1、复习高数<br>2、准备明天的英语口语考试</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>晚上</strong></td>\n<td align=\"center\">1、军事理论课[ ]<br>2、下课早的话就回工作室学习  [ ]</td>\n<td align=\"center\">1、工作室学长讲课<br>2、做英语阅读<br>3、阳光打卡</td>\n<td align=\"center\">1、完成体育的8000字论文</td>\n<td align=\"center\">1、工作室学长讲Python<br>2、装Linux系统</td>\n<td align=\"center\">1、思修课（玩玩服务器吧）</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"1、第十五周的周任务\"><a href=\"#1、第十五周的周任务\" class=\"headerlink\" title=\"1、第十五周的周任务\"></a>1、第十五周的周任务</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 1、星期一课比较多大块的时间不是很多，上午英语听力课，下午高数课，域名终于批下来了，重新部署了一下自己的个人网站，进行了一定的美化，虽然还是很丑。。。晚上军事理论课如果没事的话可以做做高数啥的，下课下的早的话还是回工作室吧，今天阳光长跑需要打卡3次。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 2、星期二课比较少就只有一节体育课。多练习了几次三级蛙跳虽然最后还是没及格但是比体测的时候1.44的成绩好太多了，也算是有很大进步吧。下午本来说是复习高数的后来忙着弄FTP服务器去了不知不觉地一下午就过去了，最后命令行配置FTP服务器还是失败了，害。晚上听学长讲了一下计算机硬件有关的知识，再通过宝塔把FTP服务器弄好了，做了做阅读，一天就这么结束了。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 3、星期三课有点多，主要是下午是一下午的工训课。本来说早上是要来工作室记单词的，但实在是太困了而且体育课三级蛙跳把腰和大腿都有点拉伤了就没起来。今天一天走路都不舒服，害，所以下学期体育课千万不要选趣味田径。晚上的话心情不好，就把她的体育论文给写完吧，之前写到了6000字，正好今天晚上一晚上写完然后查个重，希望不要爆红。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 4、星期四课算是比较少的了，上午腰实在是不舒服就请了假去医院拍了片子看了一下。所以说体育项目的话自己实在是没那个水准就不要强求自己，不然很容易受伤的。下午的话在工作室学习了一下午，完成了Nextcloud的部署，复习了高数balabala，晚上的话听工作室的学长讲爬虫，但是好困所以听的就不是很明白。装了个Linux系统，感觉Linux系统比Windows好看了不少，简洁了不少。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 5、星期五的话课算不上多也算不上少吧，比前几天要稍微闲一点。下午上机课的时候把模拟cstring的几个库函数写了一下，然后把计算机基础的PPT测试刷到了满分。拿了好几个快递，晚上的话就放松休息一下，看看高数？玩玩服务器？聊聊天吧。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 6、双休自然是没课的，上午睡了个懒觉，然后10点到的工作室，到了之后先学了一下Python的内容。后来想起自己的小游戏似乎还没有一个计算分数的功能，又去完善了一下。弄到了下午两点多钟差不多是全部弄完了 ，把英语的口语考试的题目准备一下吧，毕竟下周一就要考试了。</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 7、今天又是没课的一天，感觉效率不是很高呀，做事的时候不是很专注，总是想着做别的事去了。上午本来说是寝室的大扫除的，结果早上9点多了室友都还没有起来，最后实在等不了了，就出门了。来工作室以后先查博客解决了一下昨天遇到了403和404错误，问题就出在了没有配置好运行目录导致nginx没有办法访问到index.php等文件导致的。下午的话就做了做高数课本上的题目，然后准备了一下明天的英语口语考试。希望明天英语口语考试的时候，自己读慢一点，然后回答问题的时候不要紧张就好，加油。</li>\n</ul>\n<h2 id=\"2、第十五周的周总结\"><a href=\"#2、第十五周的周总结\" class=\"headerlink\" title=\"2、第十五周的周总结\"></a>2、第十五周的周总结</h2><h1 id=\"考试时间记录\"><a href=\"#考试时间记录\" class=\"headerlink\" title=\"考试时间记录\"></a>考试时间记录</h1><h2 id=\"1、英语\"><a href=\"#1、英语\" class=\"headerlink\" title=\"1、英语\"></a>1、英语</h2><p><strong>时间：</strong>2020年1月2日  <strong>上午 9：00-11：00</strong></p>\n<p><strong>地点：</strong>C-1117</p>\n<h2 id=\"2、C语言\"><a href=\"#2、C语言\" class=\"headerlink\" title=\"2、C语言\"></a>2、C语言</h2><p><strong>时间：</strong>2020年12月24日 <strong>晚上19:00~20:50</strong></p>\n<p><strong>地点：</strong>J4机房</p>\n<p><strong>座位：</strong>039</p>\n<h2 id=\"3、高等数学（一）\"><a href=\"#3、高等数学（一）\" class=\"headerlink\" title=\"3、高等数学（一）\"></a>3、高等数学（一）</h2><h2 id=\"4、思修\"><a href=\"#4、思修\" class=\"headerlink\" title=\"4、思修\"></a>4、思修</h2><p><strong>时间：</strong>2020/12/24  <strong>下午 14:00–15:40</strong> </p>\n<p><strong>地点：</strong>S-1631</p>\n","slug":"Dayplan","updated":"2020-12-20T07:53:55.362Z","comments":true,"link":"","permalink":"http://example.com/2020/12/10/Dayplan/","excerpt":"个人计划","categories":[{"name":"个人计划","slug":"个人计划","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"Plan","slug":"Plan","permalink":"http://example.com/tags/Plan/"}]}]